//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.3.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class AnswerClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    getMyAnswers(signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/answers/my";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMyAnswers(_response);
        });
    }

    protected processGetMyAnswers(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    generateFakeAnswers(signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/answers/generate";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGenerateFakeAnswers(_response);
        });
    }

    protected processGenerateFakeAnswers(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Get all records of type T
     * @param currentPage (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @param filter (optional) 
     * @return A PagedResult T with queryable holding the items
     */
    getAll(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfAnswerResponseDto> {
        let url_ = this.baseUrl + "/api/answers?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<PagedResultOfAnswerResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfAnswerResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfAnswerResponseDto>(null as any);
    }

    /**
     * Create a record of type T
     * @param body The RequestDto to create object
     * @return The created item T
     */
    create(body: AnswerRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/answers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Get a record of type T by id
     * @param id The id of the item
     * @return A item T
     */
    get(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/answers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Delete a record of type T by id
     * @param id The id of the item to be removed
     * @return True on success, false otherwise
     */
    delete(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/answers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Update a record of type T by id
     * @param id The id of the item to be updated
     * @param body The updated body to be saved
     * @return True on success, false otherwise
     */
    update(id: string, body: AnswerRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/answers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    createWithFile(id: string | undefined, questionId: string | null | undefined, user: string | null | undefined, alternativeId: string | null | undefined, correct: boolean | undefined, quizAttemptId: string | null | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/answers/file";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (questionId !== null && questionId !== undefined)
            content_.append("QuestionId", questionId.toString());
        if (user !== null && user !== undefined)
            content_.append("User", user.toString());
        if (alternativeId !== null && alternativeId !== undefined)
            content_.append("AlternativeId", alternativeId.toString());
        if (correct === null || correct === undefined)
            throw new Error("The parameter 'correct' cannot be null.");
        else
            content_.append("Correct", correct.toString());
        if (quizAttemptId !== null && quizAttemptId !== undefined)
            content_.append("QuizAttemptId", quizAttemptId.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateWithFile(_response);
        });
    }

    protected processCreateWithFile(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    updateWithFile(idPath: string, idFormData: string | undefined, questionId: string | null | undefined, user: string | null | undefined, alternativeId: string | null | undefined, correct: boolean | undefined, quizAttemptId: string | null | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/answers/file";
        if (idPath === undefined || idPath === null)
            throw new Error("The parameter 'idPath' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + idPath));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (idFormData === null || idFormData === undefined)
            throw new Error("The parameter 'idFormData' cannot be null.");
        else
            content_.append("Id", idFormData.toString());
        if (questionId !== null && questionId !== undefined)
            content_.append("QuestionId", questionId.toString());
        if (user !== null && user !== undefined)
            content_.append("User", user.toString());
        if (alternativeId !== null && alternativeId !== undefined)
            content_.append("AlternativeId", alternativeId.toString());
        if (correct === null || correct === undefined)
            throw new Error("The parameter 'correct' cannot be null.");
        else
            content_.append("Correct", correct.toString());
        if (quizAttemptId !== null && quizAttemptId !== undefined)
            content_.append("QuizAttemptId", quizAttemptId.toString());

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateWithFile(_response);
        });
    }

    protected processUpdateWithFile(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload(file: FileParameter | undefined, fileName: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/answers/upload?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

export class AuthClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    signIn(user: UserCreateRequest, signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/auth/signin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSignIn(_response);
        });
    }

    protected processSignIn(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }

    signUp(user: SignupUserRequest, signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/auth/signup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSignUp(_response);
        });
    }

    protected processSignUp(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }

    create(user: UserCreateRequest, signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/auth/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }

    remove(id: string | undefined, signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/auth/remove?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemove(_response);
        });
    }

    protected processRemove(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }
}

export class DisciplinesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    /**
     * Get all records of type T
     * @param currentPage (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @param filter (optional) 
     * @return A PagedResult T with queryable holding the items
     */
    getAll(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfDisciplineResponseDto> {
        let url_ = this.baseUrl + "/api/disciplines?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<PagedResultOfDisciplineResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfDisciplineResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfDisciplineResponseDto>(null as any);
    }

    /**
     * Create a record of type T
     * @param body The RequestDto to create object
     * @return The created item T
     */
    create(body: DisciplineRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/disciplines";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Get a record of type T by id
     * @param id The id of the item
     * @return A item T
     */
    get(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/disciplines/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Delete a record of type T by id
     * @param id The id of the item to be removed
     * @return True on success, false otherwise
     */
    delete(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/disciplines/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Update a record of type T by id
     * @param id The id of the item to be updated
     * @param body The updated body to be saved
     * @return True on success, false otherwise
     */
    update(id: string, body: DisciplineRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/disciplines/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    createWithFile(id: string | undefined, name: string | undefined, description: string | undefined, image: string | null | undefined, parentId: string | null | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/disciplines/file";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (description === null || description === undefined)
            throw new Error("The parameter 'description' cannot be null.");
        else
            content_.append("Description", description.toString());
        if (image !== null && image !== undefined)
            content_.append("Image", image.toString());
        if (parentId !== null && parentId !== undefined)
            content_.append("ParentId", parentId.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateWithFile(_response);
        });
    }

    protected processCreateWithFile(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    updateWithFile(idPath: string, idFormData: string | undefined, name: string | undefined, description: string | undefined, image: string | null | undefined, parentId: string | null | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/disciplines/file";
        if (idPath === undefined || idPath === null)
            throw new Error("The parameter 'idPath' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + idPath));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (idFormData === null || idFormData === undefined)
            throw new Error("The parameter 'idFormData' cannot be null.");
        else
            content_.append("Id", idFormData.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (description === null || description === undefined)
            throw new Error("The parameter 'description' cannot be null.");
        else
            content_.append("Description", description.toString());
        if (image !== null && image !== undefined)
            content_.append("Image", image.toString());
        if (parentId !== null && parentId !== undefined)
            content_.append("ParentId", parentId.toString());

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateWithFile(_response);
        });
    }

    protected processUpdateWithFile(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload(file: FileParameter | undefined, fileName: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/disciplines/upload?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

export class ErrorClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    handleErrorDevelopmentGET(signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/error";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHandleErrorDevelopmentGET(_response);
        });
    }

    protected processHandleErrorDevelopmentGET(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    handleErrorDevelopmentPOST(signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/error";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHandleErrorDevelopmentPOST(_response);
        });
    }

    protected processHandleErrorDevelopmentPOST(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

export class InstitutionsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    /**
     * Get all records of type T
     * @param currentPage (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @param filter (optional) 
     * @return A PagedResult T with queryable holding the items
     */
    getAll(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfInstitutionResponseDto> {
        let url_ = this.baseUrl + "/api/institutions?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<PagedResultOfInstitutionResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfInstitutionResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfInstitutionResponseDto>(null as any);
    }

    /**
     * Create a record of type T
     * @param body The RequestDto to create object
     * @return The created item T
     */
    create(body: InstitutionRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/institutions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Get a record of type T by id
     * @param id The id of the item
     * @return A item T
     */
    get(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/institutions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Delete a record of type T by id
     * @param id The id of the item to be removed
     * @return True on success, false otherwise
     */
    delete(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/institutions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Update a record of type T by id
     * @param id The id of the item to be updated
     * @param body The updated body to be saved
     * @return True on success, false otherwise
     */
    update(id: string, body: InstitutionRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/institutions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    createWithFile(id: string | undefined, name: string | undefined, state: string | undefined, stadual: boolean | undefined, privateInstitution: boolean | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/institutions/file";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (state === null || state === undefined)
            throw new Error("The parameter 'state' cannot be null.");
        else
            content_.append("State", state.toString());
        if (stadual === null || stadual === undefined)
            throw new Error("The parameter 'stadual' cannot be null.");
        else
            content_.append("Stadual", stadual.toString());
        if (privateInstitution === null || privateInstitution === undefined)
            throw new Error("The parameter 'privateInstitution' cannot be null.");
        else
            content_.append("PrivateInstitution", privateInstitution.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateWithFile(_response);
        });
    }

    protected processCreateWithFile(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    updateWithFile(idPath: string, idFormData: string | undefined, name: string | undefined, state: string | undefined, stadual: boolean | undefined, privateInstitution: boolean | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/institutions/file";
        if (idPath === undefined || idPath === null)
            throw new Error("The parameter 'idPath' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + idPath));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (idFormData === null || idFormData === undefined)
            throw new Error("The parameter 'idFormData' cannot be null.");
        else
            content_.append("Id", idFormData.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (state === null || state === undefined)
            throw new Error("The parameter 'state' cannot be null.");
        else
            content_.append("State", state.toString());
        if (stadual === null || stadual === undefined)
            throw new Error("The parameter 'stadual' cannot be null.");
        else
            content_.append("Stadual", stadual.toString());
        if (privateInstitution === null || privateInstitution === undefined)
            throw new Error("The parameter 'privateInstitution' cannot be null.");
        else
            content_.append("PrivateInstitution", privateInstitution.toString());

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateWithFile(_response);
        });
    }

    protected processUpdateWithFile(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload(file: FileParameter | undefined, fileName: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/institutions/upload?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

export class ObservationsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    create(body: ObservationRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/observations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Get all records of type T
     * @param currentPage (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @param filter (optional) 
     * @return A PagedResult T with queryable holding the items
     */
    getAll(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfObservationResponseDto> {
        let url_ = this.baseUrl + "/api/observations?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<PagedResultOfObservationResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfObservationResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfObservationResponseDto>(null as any);
    }

    /**
     * Get a record of type T by id
     * @param id The id of the item
     * @return A item T
     */
    get(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/observations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Delete a record of type T by id
     * @param id The id of the item to be removed
     * @return True on success, false otherwise
     */
    delete(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/observations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Update a record of type T by id
     * @param id The id of the item to be updated
     * @param body The updated body to be saved
     * @return True on success, false otherwise
     */
    update(id: string, body: ObservationRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/observations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    createWithFile(id: string | undefined, questionId: string | null | undefined, question_Id: string | undefined, question_Year: number | undefined, question_Board: string | undefined, question_Image: string | null | undefined, question_Text: string | null | undefined, question_Score: number | undefined, question_Active: boolean | undefined, question_QuestionNumber: number | null | undefined, question_InstitutionId: string | null | undefined, question_QuestionBankId: string | null | undefined, question_QuizAttemptId: string | null | undefined, question_DisciplineId: string | null | undefined, question_Alternatives: AlternativeRequestDto[] | null | undefined, question_Discipline_Id: string | undefined, question_Discipline_Name: string | undefined, question_Discipline_Description: string | undefined, question_Discipline_Image: string | null | undefined, question_Discipline_ParentId: string | null | undefined, question_IsValid: boolean | undefined, question_File: FileParameter | null | undefined, observationRequestId: string | null | undefined, observationRequest_Id: string | undefined, observationRequest_QuestionId: string | null | undefined, observationRequest_Question_Id: string | undefined, observationRequest_Question_Year: number | undefined, observationRequest_Question_Board: string | undefined, observationRequest_Question_Image: string | null | undefined, observationRequest_Question_Text: string | null | undefined, observationRequest_Question_Score: number | undefined, observationRequest_Question_Active: boolean | undefined, observationRequest_Question_QuestionNumber: number | null | undefined, observationRequest_Question_InstitutionId: string | null | undefined, observationRequest_Question_QuestionBankId: string | null | undefined, observationRequest_Question_QuizAttemptId: string | null | undefined, observationRequest_Question_DisciplineId: string | null | undefined, observationRequest_Question_Alternatives: AlternativeRequestDto[] | null | undefined, observationRequest_Question_Discipline_Id: string | undefined, observationRequest_Question_Discipline_Name: string | undefined, observationRequest_Question_Discipline_Description: string | undefined, observationRequest_Question_Discipline_Image: string | null | undefined, observationRequest_Question_Discipline_ParentId: string | null | undefined, observationRequest_Question_IsValid: boolean | undefined, observationRequest_Question_File: FileParameter | null | undefined, observationRequest_ObservationRequestId: string | null | undefined, observationRequest_ObservationRequest_Id: string | undefined, observationRequest_ObservationRequest_QuestionId: string | null | undefined, observationRequest_ObservationRequest_Question_Id: string | undefined, observationRequest_ObservationRequest_Question_Year: number | undefined, observationRequest_ObservationRequest_Question_Board: string | undefined, observationRequest_ObservationRequest_Question_Image: string | null | undefined, observationRequest_ObservationRequest_Question_Text: string | null | undefined, observationRequest_ObservationRequest_Question_Score: number | undefined, observationRequest_ObservationRequest_Question_Active: boolean | undefined, observationRequest_ObservationRequest_Question_QuestionNumber: number | null | undefined, observationRequest_ObservationRequest_Question_InstitutionId: string | null | undefined, observationRequest_ObservationRequest_Question_QuestionBankId: string | null | undefined, observationRequest_ObservationRequest_Question_QuizAttemptId: string | null | undefined, observationRequest_ObservationRequest_Question_DisciplineId: string | null | undefined, observationRequest_ObservationRequest_Question_Alternatives: AlternativeRequestDto[] | null | undefined, observationRequest_ObservationRequest_Question_Discipline_Id: string | undefined, observationRequest_ObservationRequest_Question_Discipline_Name: string | undefined, observationRequest_ObservationRequest_Question_Discipline_Description: string | undefined, observationRequest_ObservationRequest_Question_Discipline_Image: string | null | undefined, observationRequest_ObservationRequest_Question_Discipline_ParentId: string | null | undefined, observationRequest_ObservationRequest_Question_IsValid: boolean | undefined, observationRequest_ObservationRequest_Question_File: FileParameter | null | undefined, observationRequest_ObservationRequest_ObservationRequestId: string | null | undefined, observationRequest_ObservationRequest_ObservationRequest: ObservationRequestDto | null | undefined, observationRequest_ObservationRequest_Text: string | undefined, observationRequest_ObservationRequest_User: string | undefined, observationRequest_Text: string | undefined, observationRequest_User: string | undefined, text: string | undefined, user: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/observations/file";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (questionId !== null && questionId !== undefined)
            content_.append("QuestionId", questionId.toString());
        if (question_Id === null || question_Id === undefined)
            throw new Error("The parameter 'question_Id' cannot be null.");
        else
            content_.append("Question.Id", question_Id.toString());
        if (question_Year === null || question_Year === undefined)
            throw new Error("The parameter 'question_Year' cannot be null.");
        else
            content_.append("Question.Year", question_Year.toString());
        if (question_Board === null || question_Board === undefined)
            throw new Error("The parameter 'question_Board' cannot be null.");
        else
            content_.append("Question.Board", question_Board.toString());
        if (question_Image !== null && question_Image !== undefined)
            content_.append("Question.Image", question_Image.toString());
        if (question_Text !== null && question_Text !== undefined)
            content_.append("Question.Text", question_Text.toString());
        if (question_Score === null || question_Score === undefined)
            throw new Error("The parameter 'question_Score' cannot be null.");
        else
            content_.append("Question.Score", question_Score.toString());
        if (question_Active === null || question_Active === undefined)
            throw new Error("The parameter 'question_Active' cannot be null.");
        else
            content_.append("Question.Active", question_Active.toString());
        if (question_QuestionNumber !== null && question_QuestionNumber !== undefined)
            content_.append("Question.QuestionNumber", question_QuestionNumber.toString());
        if (question_InstitutionId !== null && question_InstitutionId !== undefined)
            content_.append("Question.InstitutionId", question_InstitutionId.toString());
        if (question_QuestionBankId !== null && question_QuestionBankId !== undefined)
            content_.append("Question.QuestionBankId", question_QuestionBankId.toString());
        if (question_QuizAttemptId !== null && question_QuizAttemptId !== undefined)
            content_.append("Question.QuizAttemptId", question_QuizAttemptId.toString());
        if (question_DisciplineId !== null && question_DisciplineId !== undefined)
            content_.append("Question.DisciplineId", question_DisciplineId.toString());
        if (question_Alternatives !== null && question_Alternatives !== undefined)
            question_Alternatives.forEach(item_ => content_.append("Question.Alternatives", item_.toString()));
        if (question_Discipline_Id === null || question_Discipline_Id === undefined)
            throw new Error("The parameter 'question_Discipline_Id' cannot be null.");
        else
            content_.append("Question.Discipline.Id", question_Discipline_Id.toString());
        if (question_Discipline_Name === null || question_Discipline_Name === undefined)
            throw new Error("The parameter 'question_Discipline_Name' cannot be null.");
        else
            content_.append("Question.Discipline.Name", question_Discipline_Name.toString());
        if (question_Discipline_Description === null || question_Discipline_Description === undefined)
            throw new Error("The parameter 'question_Discipline_Description' cannot be null.");
        else
            content_.append("Question.Discipline.Description", question_Discipline_Description.toString());
        if (question_Discipline_Image !== null && question_Discipline_Image !== undefined)
            content_.append("Question.Discipline.Image", question_Discipline_Image.toString());
        if (question_Discipline_ParentId !== null && question_Discipline_ParentId !== undefined)
            content_.append("Question.Discipline.ParentId", question_Discipline_ParentId.toString());
        if (question_IsValid === null || question_IsValid === undefined)
            throw new Error("The parameter 'question_IsValid' cannot be null.");
        else
            content_.append("Question.IsValid", question_IsValid.toString());
        if (question_File !== null && question_File !== undefined)
            content_.append("Question.File", question_File.data, question_File.fileName ? question_File.fileName : "Question.File");
        if (observationRequestId !== null && observationRequestId !== undefined)
            content_.append("ObservationRequestId", observationRequestId.toString());
        if (observationRequest_Id === null || observationRequest_Id === undefined)
            throw new Error("The parameter 'observationRequest_Id' cannot be null.");
        else
            content_.append("ObservationRequest.Id", observationRequest_Id.toString());
        if (observationRequest_QuestionId !== null && observationRequest_QuestionId !== undefined)
            content_.append("ObservationRequest.QuestionId", observationRequest_QuestionId.toString());
        if (observationRequest_Question_Id === null || observationRequest_Question_Id === undefined)
            throw new Error("The parameter 'observationRequest_Question_Id' cannot be null.");
        else
            content_.append("ObservationRequest.Question.Id", observationRequest_Question_Id.toString());
        if (observationRequest_Question_Year === null || observationRequest_Question_Year === undefined)
            throw new Error("The parameter 'observationRequest_Question_Year' cannot be null.");
        else
            content_.append("ObservationRequest.Question.Year", observationRequest_Question_Year.toString());
        if (observationRequest_Question_Board === null || observationRequest_Question_Board === undefined)
            throw new Error("The parameter 'observationRequest_Question_Board' cannot be null.");
        else
            content_.append("ObservationRequest.Question.Board", observationRequest_Question_Board.toString());
        if (observationRequest_Question_Image !== null && observationRequest_Question_Image !== undefined)
            content_.append("ObservationRequest.Question.Image", observationRequest_Question_Image.toString());
        if (observationRequest_Question_Text !== null && observationRequest_Question_Text !== undefined)
            content_.append("ObservationRequest.Question.Text", observationRequest_Question_Text.toString());
        if (observationRequest_Question_Score === null || observationRequest_Question_Score === undefined)
            throw new Error("The parameter 'observationRequest_Question_Score' cannot be null.");
        else
            content_.append("ObservationRequest.Question.Score", observationRequest_Question_Score.toString());
        if (observationRequest_Question_Active === null || observationRequest_Question_Active === undefined)
            throw new Error("The parameter 'observationRequest_Question_Active' cannot be null.");
        else
            content_.append("ObservationRequest.Question.Active", observationRequest_Question_Active.toString());
        if (observationRequest_Question_QuestionNumber !== null && observationRequest_Question_QuestionNumber !== undefined)
            content_.append("ObservationRequest.Question.QuestionNumber", observationRequest_Question_QuestionNumber.toString());
        if (observationRequest_Question_InstitutionId !== null && observationRequest_Question_InstitutionId !== undefined)
            content_.append("ObservationRequest.Question.InstitutionId", observationRequest_Question_InstitutionId.toString());
        if (observationRequest_Question_QuestionBankId !== null && observationRequest_Question_QuestionBankId !== undefined)
            content_.append("ObservationRequest.Question.QuestionBankId", observationRequest_Question_QuestionBankId.toString());
        if (observationRequest_Question_QuizAttemptId !== null && observationRequest_Question_QuizAttemptId !== undefined)
            content_.append("ObservationRequest.Question.QuizAttemptId", observationRequest_Question_QuizAttemptId.toString());
        if (observationRequest_Question_DisciplineId !== null && observationRequest_Question_DisciplineId !== undefined)
            content_.append("ObservationRequest.Question.DisciplineId", observationRequest_Question_DisciplineId.toString());
        if (observationRequest_Question_Alternatives !== null && observationRequest_Question_Alternatives !== undefined)
            observationRequest_Question_Alternatives.forEach(item_ => content_.append("ObservationRequest.Question.Alternatives", item_.toString()));
        if (observationRequest_Question_Discipline_Id === null || observationRequest_Question_Discipline_Id === undefined)
            throw new Error("The parameter 'observationRequest_Question_Discipline_Id' cannot be null.");
        else
            content_.append("ObservationRequest.Question.Discipline.Id", observationRequest_Question_Discipline_Id.toString());
        if (observationRequest_Question_Discipline_Name === null || observationRequest_Question_Discipline_Name === undefined)
            throw new Error("The parameter 'observationRequest_Question_Discipline_Name' cannot be null.");
        else
            content_.append("ObservationRequest.Question.Discipline.Name", observationRequest_Question_Discipline_Name.toString());
        if (observationRequest_Question_Discipline_Description === null || observationRequest_Question_Discipline_Description === undefined)
            throw new Error("The parameter 'observationRequest_Question_Discipline_Description' cannot be null.");
        else
            content_.append("ObservationRequest.Question.Discipline.Description", observationRequest_Question_Discipline_Description.toString());
        if (observationRequest_Question_Discipline_Image !== null && observationRequest_Question_Discipline_Image !== undefined)
            content_.append("ObservationRequest.Question.Discipline.Image", observationRequest_Question_Discipline_Image.toString());
        if (observationRequest_Question_Discipline_ParentId !== null && observationRequest_Question_Discipline_ParentId !== undefined)
            content_.append("ObservationRequest.Question.Discipline.ParentId", observationRequest_Question_Discipline_ParentId.toString());
        if (observationRequest_Question_IsValid === null || observationRequest_Question_IsValid === undefined)
            throw new Error("The parameter 'observationRequest_Question_IsValid' cannot be null.");
        else
            content_.append("ObservationRequest.Question.IsValid", observationRequest_Question_IsValid.toString());
        if (observationRequest_Question_File !== null && observationRequest_Question_File !== undefined)
            content_.append("ObservationRequest.Question.File", observationRequest_Question_File.data, observationRequest_Question_File.fileName ? observationRequest_Question_File.fileName : "ObservationRequest.Question.File");
        if (observationRequest_ObservationRequestId !== null && observationRequest_ObservationRequestId !== undefined)
            content_.append("ObservationRequest.ObservationRequestId", observationRequest_ObservationRequestId.toString());
        if (observationRequest_ObservationRequest_Id === null || observationRequest_ObservationRequest_Id === undefined)
            throw new Error("The parameter 'observationRequest_ObservationRequest_Id' cannot be null.");
        else
            content_.append("ObservationRequest.ObservationRequest.Id", observationRequest_ObservationRequest_Id.toString());
        if (observationRequest_ObservationRequest_QuestionId !== null && observationRequest_ObservationRequest_QuestionId !== undefined)
            content_.append("ObservationRequest.ObservationRequest.QuestionId", observationRequest_ObservationRequest_QuestionId.toString());
        if (observationRequest_ObservationRequest_Question_Id === null || observationRequest_ObservationRequest_Question_Id === undefined)
            throw new Error("The parameter 'observationRequest_ObservationRequest_Question_Id' cannot be null.");
        else
            content_.append("ObservationRequest.ObservationRequest.Question.Id", observationRequest_ObservationRequest_Question_Id.toString());
        if (observationRequest_ObservationRequest_Question_Year === null || observationRequest_ObservationRequest_Question_Year === undefined)
            throw new Error("The parameter 'observationRequest_ObservationRequest_Question_Year' cannot be null.");
        else
            content_.append("ObservationRequest.ObservationRequest.Question.Year", observationRequest_ObservationRequest_Question_Year.toString());
        if (observationRequest_ObservationRequest_Question_Board === null || observationRequest_ObservationRequest_Question_Board === undefined)
            throw new Error("The parameter 'observationRequest_ObservationRequest_Question_Board' cannot be null.");
        else
            content_.append("ObservationRequest.ObservationRequest.Question.Board", observationRequest_ObservationRequest_Question_Board.toString());
        if (observationRequest_ObservationRequest_Question_Image !== null && observationRequest_ObservationRequest_Question_Image !== undefined)
            content_.append("ObservationRequest.ObservationRequest.Question.Image", observationRequest_ObservationRequest_Question_Image.toString());
        if (observationRequest_ObservationRequest_Question_Text !== null && observationRequest_ObservationRequest_Question_Text !== undefined)
            content_.append("ObservationRequest.ObservationRequest.Question.Text", observationRequest_ObservationRequest_Question_Text.toString());
        if (observationRequest_ObservationRequest_Question_Score === null || observationRequest_ObservationRequest_Question_Score === undefined)
            throw new Error("The parameter 'observationRequest_ObservationRequest_Question_Score' cannot be null.");
        else
            content_.append("ObservationRequest.ObservationRequest.Question.Score", observationRequest_ObservationRequest_Question_Score.toString());
        if (observationRequest_ObservationRequest_Question_Active === null || observationRequest_ObservationRequest_Question_Active === undefined)
            throw new Error("The parameter 'observationRequest_ObservationRequest_Question_Active' cannot be null.");
        else
            content_.append("ObservationRequest.ObservationRequest.Question.Active", observationRequest_ObservationRequest_Question_Active.toString());
        if (observationRequest_ObservationRequest_Question_QuestionNumber !== null && observationRequest_ObservationRequest_Question_QuestionNumber !== undefined)
            content_.append("ObservationRequest.ObservationRequest.Question.QuestionNumber", observationRequest_ObservationRequest_Question_QuestionNumber.toString());
        if (observationRequest_ObservationRequest_Question_InstitutionId !== null && observationRequest_ObservationRequest_Question_InstitutionId !== undefined)
            content_.append("ObservationRequest.ObservationRequest.Question.InstitutionId", observationRequest_ObservationRequest_Question_InstitutionId.toString());
        if (observationRequest_ObservationRequest_Question_QuestionBankId !== null && observationRequest_ObservationRequest_Question_QuestionBankId !== undefined)
            content_.append("ObservationRequest.ObservationRequest.Question.QuestionBankId", observationRequest_ObservationRequest_Question_QuestionBankId.toString());
        if (observationRequest_ObservationRequest_Question_QuizAttemptId !== null && observationRequest_ObservationRequest_Question_QuizAttemptId !== undefined)
            content_.append("ObservationRequest.ObservationRequest.Question.QuizAttemptId", observationRequest_ObservationRequest_Question_QuizAttemptId.toString());
        if (observationRequest_ObservationRequest_Question_DisciplineId !== null && observationRequest_ObservationRequest_Question_DisciplineId !== undefined)
            content_.append("ObservationRequest.ObservationRequest.Question.DisciplineId", observationRequest_ObservationRequest_Question_DisciplineId.toString());
        if (observationRequest_ObservationRequest_Question_Alternatives !== null && observationRequest_ObservationRequest_Question_Alternatives !== undefined)
            observationRequest_ObservationRequest_Question_Alternatives.forEach(item_ => content_.append("ObservationRequest.ObservationRequest.Question.Alternatives", item_.toString()));
        if (observationRequest_ObservationRequest_Question_Discipline_Id === null || observationRequest_ObservationRequest_Question_Discipline_Id === undefined)
            throw new Error("The parameter 'observationRequest_ObservationRequest_Question_Discipline_Id' cannot be null.");
        else
            content_.append("ObservationRequest.ObservationRequest.Question.Discipline.Id", observationRequest_ObservationRequest_Question_Discipline_Id.toString());
        if (observationRequest_ObservationRequest_Question_Discipline_Name === null || observationRequest_ObservationRequest_Question_Discipline_Name === undefined)
            throw new Error("The parameter 'observationRequest_ObservationRequest_Question_Discipline_Name' cannot be null.");
        else
            content_.append("ObservationRequest.ObservationRequest.Question.Discipline.Name", observationRequest_ObservationRequest_Question_Discipline_Name.toString());
        if (observationRequest_ObservationRequest_Question_Discipline_Description === null || observationRequest_ObservationRequest_Question_Discipline_Description === undefined)
            throw new Error("The parameter 'observationRequest_ObservationRequest_Question_Discipline_Description' cannot be null.");
        else
            content_.append("ObservationRequest.ObservationRequest.Question.Discipline.Description", observationRequest_ObservationRequest_Question_Discipline_Description.toString());
        if (observationRequest_ObservationRequest_Question_Discipline_Image !== null && observationRequest_ObservationRequest_Question_Discipline_Image !== undefined)
            content_.append("ObservationRequest.ObservationRequest.Question.Discipline.Image", observationRequest_ObservationRequest_Question_Discipline_Image.toString());
        if (observationRequest_ObservationRequest_Question_Discipline_ParentId !== null && observationRequest_ObservationRequest_Question_Discipline_ParentId !== undefined)
            content_.append("ObservationRequest.ObservationRequest.Question.Discipline.ParentId", observationRequest_ObservationRequest_Question_Discipline_ParentId.toString());
        if (observationRequest_ObservationRequest_Question_IsValid === null || observationRequest_ObservationRequest_Question_IsValid === undefined)
            throw new Error("The parameter 'observationRequest_ObservationRequest_Question_IsValid' cannot be null.");
        else
            content_.append("ObservationRequest.ObservationRequest.Question.IsValid", observationRequest_ObservationRequest_Question_IsValid.toString());
        if (observationRequest_ObservationRequest_Question_File !== null && observationRequest_ObservationRequest_Question_File !== undefined)
            content_.append("ObservationRequest.ObservationRequest.Question.File", observationRequest_ObservationRequest_Question_File.data, observationRequest_ObservationRequest_Question_File.fileName ? observationRequest_ObservationRequest_Question_File.fileName : "ObservationRequest.ObservationRequest.Question.File");
        if (observationRequest_ObservationRequest_ObservationRequestId !== null && observationRequest_ObservationRequest_ObservationRequestId !== undefined)
            content_.append("ObservationRequest.ObservationRequest.ObservationRequestId", observationRequest_ObservationRequest_ObservationRequestId.toString());
        if (observationRequest_ObservationRequest_ObservationRequest !== null && observationRequest_ObservationRequest_ObservationRequest !== undefined)
            content_.append("ObservationRequest.ObservationRequest.ObservationRequest", JSON.stringify(observationRequest_ObservationRequest_ObservationRequest));
        if (observationRequest_ObservationRequest_Text === null || observationRequest_ObservationRequest_Text === undefined)
            throw new Error("The parameter 'observationRequest_ObservationRequest_Text' cannot be null.");
        else
            content_.append("ObservationRequest.ObservationRequest.Text", observationRequest_ObservationRequest_Text.toString());
        if (observationRequest_ObservationRequest_User === null || observationRequest_ObservationRequest_User === undefined)
            throw new Error("The parameter 'observationRequest_ObservationRequest_User' cannot be null.");
        else
            content_.append("ObservationRequest.ObservationRequest.User", observationRequest_ObservationRequest_User.toString());
        if (observationRequest_Text === null || observationRequest_Text === undefined)
            throw new Error("The parameter 'observationRequest_Text' cannot be null.");
        else
            content_.append("ObservationRequest.Text", observationRequest_Text.toString());
        if (observationRequest_User === null || observationRequest_User === undefined)
            throw new Error("The parameter 'observationRequest_User' cannot be null.");
        else
            content_.append("ObservationRequest.User", observationRequest_User.toString());
        if (text === null || text === undefined)
            throw new Error("The parameter 'text' cannot be null.");
        else
            content_.append("Text", text.toString());
        if (user === null || user === undefined)
            throw new Error("The parameter 'user' cannot be null.");
        else
            content_.append("User", user.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateWithFile(_response);
        });
    }

    protected processCreateWithFile(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    updateWithFile(idPath: string, idFormData: string | undefined, questionId: string | null | undefined, question_Id: string | undefined, question_Year: number | undefined, question_Board: string | undefined, question_Image: string | null | undefined, question_Text: string | null | undefined, question_Score: number | undefined, question_Active: boolean | undefined, question_QuestionNumber: number | null | undefined, question_InstitutionId: string | null | undefined, question_QuestionBankId: string | null | undefined, question_QuizAttemptId: string | null | undefined, question_DisciplineId: string | null | undefined, question_Alternatives: AlternativeRequestDto[] | null | undefined, question_Discipline_Id: string | undefined, question_Discipline_Name: string | undefined, question_Discipline_Description: string | undefined, question_Discipline_Image: string | null | undefined, question_Discipline_ParentId: string | null | undefined, question_IsValid: boolean | undefined, question_File: FileParameter | null | undefined, observationRequestId: string | null | undefined, observationRequest_Id: string | undefined, observationRequest_QuestionId: string | null | undefined, observationRequest_Question_Id: string | undefined, observationRequest_Question_Year: number | undefined, observationRequest_Question_Board: string | undefined, observationRequest_Question_Image: string | null | undefined, observationRequest_Question_Text: string | null | undefined, observationRequest_Question_Score: number | undefined, observationRequest_Question_Active: boolean | undefined, observationRequest_Question_QuestionNumber: number | null | undefined, observationRequest_Question_InstitutionId: string | null | undefined, observationRequest_Question_QuestionBankId: string | null | undefined, observationRequest_Question_QuizAttemptId: string | null | undefined, observationRequest_Question_DisciplineId: string | null | undefined, observationRequest_Question_Alternatives: AlternativeRequestDto[] | null | undefined, observationRequest_Question_Discipline_Id: string | undefined, observationRequest_Question_Discipline_Name: string | undefined, observationRequest_Question_Discipline_Description: string | undefined, observationRequest_Question_Discipline_Image: string | null | undefined, observationRequest_Question_Discipline_ParentId: string | null | undefined, observationRequest_Question_IsValid: boolean | undefined, observationRequest_Question_File: FileParameter | null | undefined, observationRequest_ObservationRequestId: string | null | undefined, observationRequest_ObservationRequest_Id: string | undefined, observationRequest_ObservationRequest_QuestionId: string | null | undefined, observationRequest_ObservationRequest_Question_Id: string | undefined, observationRequest_ObservationRequest_Question_Year: number | undefined, observationRequest_ObservationRequest_Question_Board: string | undefined, observationRequest_ObservationRequest_Question_Image: string | null | undefined, observationRequest_ObservationRequest_Question_Text: string | null | undefined, observationRequest_ObservationRequest_Question_Score: number | undefined, observationRequest_ObservationRequest_Question_Active: boolean | undefined, observationRequest_ObservationRequest_Question_QuestionNumber: number | null | undefined, observationRequest_ObservationRequest_Question_InstitutionId: string | null | undefined, observationRequest_ObservationRequest_Question_QuestionBankId: string | null | undefined, observationRequest_ObservationRequest_Question_QuizAttemptId: string | null | undefined, observationRequest_ObservationRequest_Question_DisciplineId: string | null | undefined, observationRequest_ObservationRequest_Question_Alternatives: AlternativeRequestDto[] | null | undefined, observationRequest_ObservationRequest_Question_Discipline_Id: string | undefined, observationRequest_ObservationRequest_Question_Discipline_Name: string | undefined, observationRequest_ObservationRequest_Question_Discipline_Description: string | undefined, observationRequest_ObservationRequest_Question_Discipline_Image: string | null | undefined, observationRequest_ObservationRequest_Question_Discipline_ParentId: string | null | undefined, observationRequest_ObservationRequest_Question_IsValid: boolean | undefined, observationRequest_ObservationRequest_Question_File: FileParameter | null | undefined, observationRequest_ObservationRequest_ObservationRequestId: string | null | undefined, observationRequest_ObservationRequest_ObservationRequest: ObservationRequestDto | null | undefined, observationRequest_ObservationRequest_Text: string | undefined, observationRequest_ObservationRequest_User: string | undefined, observationRequest_Text: string | undefined, observationRequest_User: string | undefined, text: string | undefined, user: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/observations/file";
        if (idPath === undefined || idPath === null)
            throw new Error("The parameter 'idPath' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + idPath));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (idFormData === null || idFormData === undefined)
            throw new Error("The parameter 'idFormData' cannot be null.");
        else
            content_.append("Id", idFormData.toString());
        if (questionId !== null && questionId !== undefined)
            content_.append("QuestionId", questionId.toString());
        if (question_Id === null || question_Id === undefined)
            throw new Error("The parameter 'question_Id' cannot be null.");
        else
            content_.append("Question.Id", question_Id.toString());
        if (question_Year === null || question_Year === undefined)
            throw new Error("The parameter 'question_Year' cannot be null.");
        else
            content_.append("Question.Year", question_Year.toString());
        if (question_Board === null || question_Board === undefined)
            throw new Error("The parameter 'question_Board' cannot be null.");
        else
            content_.append("Question.Board", question_Board.toString());
        if (question_Image !== null && question_Image !== undefined)
            content_.append("Question.Image", question_Image.toString());
        if (question_Text !== null && question_Text !== undefined)
            content_.append("Question.Text", question_Text.toString());
        if (question_Score === null || question_Score === undefined)
            throw new Error("The parameter 'question_Score' cannot be null.");
        else
            content_.append("Question.Score", question_Score.toString());
        if (question_Active === null || question_Active === undefined)
            throw new Error("The parameter 'question_Active' cannot be null.");
        else
            content_.append("Question.Active", question_Active.toString());
        if (question_QuestionNumber !== null && question_QuestionNumber !== undefined)
            content_.append("Question.QuestionNumber", question_QuestionNumber.toString());
        if (question_InstitutionId !== null && question_InstitutionId !== undefined)
            content_.append("Question.InstitutionId", question_InstitutionId.toString());
        if (question_QuestionBankId !== null && question_QuestionBankId !== undefined)
            content_.append("Question.QuestionBankId", question_QuestionBankId.toString());
        if (question_QuizAttemptId !== null && question_QuizAttemptId !== undefined)
            content_.append("Question.QuizAttemptId", question_QuizAttemptId.toString());
        if (question_DisciplineId !== null && question_DisciplineId !== undefined)
            content_.append("Question.DisciplineId", question_DisciplineId.toString());
        if (question_Alternatives !== null && question_Alternatives !== undefined)
            question_Alternatives.forEach(item_ => content_.append("Question.Alternatives", item_.toString()));
        if (question_Discipline_Id === null || question_Discipline_Id === undefined)
            throw new Error("The parameter 'question_Discipline_Id' cannot be null.");
        else
            content_.append("Question.Discipline.Id", question_Discipline_Id.toString());
        if (question_Discipline_Name === null || question_Discipline_Name === undefined)
            throw new Error("The parameter 'question_Discipline_Name' cannot be null.");
        else
            content_.append("Question.Discipline.Name", question_Discipline_Name.toString());
        if (question_Discipline_Description === null || question_Discipline_Description === undefined)
            throw new Error("The parameter 'question_Discipline_Description' cannot be null.");
        else
            content_.append("Question.Discipline.Description", question_Discipline_Description.toString());
        if (question_Discipline_Image !== null && question_Discipline_Image !== undefined)
            content_.append("Question.Discipline.Image", question_Discipline_Image.toString());
        if (question_Discipline_ParentId !== null && question_Discipline_ParentId !== undefined)
            content_.append("Question.Discipline.ParentId", question_Discipline_ParentId.toString());
        if (question_IsValid === null || question_IsValid === undefined)
            throw new Error("The parameter 'question_IsValid' cannot be null.");
        else
            content_.append("Question.IsValid", question_IsValid.toString());
        if (question_File !== null && question_File !== undefined)
            content_.append("Question.File", question_File.data, question_File.fileName ? question_File.fileName : "Question.File");
        if (observationRequestId !== null && observationRequestId !== undefined)
            content_.append("ObservationRequestId", observationRequestId.toString());
        if (observationRequest_Id === null || observationRequest_Id === undefined)
            throw new Error("The parameter 'observationRequest_Id' cannot be null.");
        else
            content_.append("ObservationRequest.Id", observationRequest_Id.toString());
        if (observationRequest_QuestionId !== null && observationRequest_QuestionId !== undefined)
            content_.append("ObservationRequest.QuestionId", observationRequest_QuestionId.toString());
        if (observationRequest_Question_Id === null || observationRequest_Question_Id === undefined)
            throw new Error("The parameter 'observationRequest_Question_Id' cannot be null.");
        else
            content_.append("ObservationRequest.Question.Id", observationRequest_Question_Id.toString());
        if (observationRequest_Question_Year === null || observationRequest_Question_Year === undefined)
            throw new Error("The parameter 'observationRequest_Question_Year' cannot be null.");
        else
            content_.append("ObservationRequest.Question.Year", observationRequest_Question_Year.toString());
        if (observationRequest_Question_Board === null || observationRequest_Question_Board === undefined)
            throw new Error("The parameter 'observationRequest_Question_Board' cannot be null.");
        else
            content_.append("ObservationRequest.Question.Board", observationRequest_Question_Board.toString());
        if (observationRequest_Question_Image !== null && observationRequest_Question_Image !== undefined)
            content_.append("ObservationRequest.Question.Image", observationRequest_Question_Image.toString());
        if (observationRequest_Question_Text !== null && observationRequest_Question_Text !== undefined)
            content_.append("ObservationRequest.Question.Text", observationRequest_Question_Text.toString());
        if (observationRequest_Question_Score === null || observationRequest_Question_Score === undefined)
            throw new Error("The parameter 'observationRequest_Question_Score' cannot be null.");
        else
            content_.append("ObservationRequest.Question.Score", observationRequest_Question_Score.toString());
        if (observationRequest_Question_Active === null || observationRequest_Question_Active === undefined)
            throw new Error("The parameter 'observationRequest_Question_Active' cannot be null.");
        else
            content_.append("ObservationRequest.Question.Active", observationRequest_Question_Active.toString());
        if (observationRequest_Question_QuestionNumber !== null && observationRequest_Question_QuestionNumber !== undefined)
            content_.append("ObservationRequest.Question.QuestionNumber", observationRequest_Question_QuestionNumber.toString());
        if (observationRequest_Question_InstitutionId !== null && observationRequest_Question_InstitutionId !== undefined)
            content_.append("ObservationRequest.Question.InstitutionId", observationRequest_Question_InstitutionId.toString());
        if (observationRequest_Question_QuestionBankId !== null && observationRequest_Question_QuestionBankId !== undefined)
            content_.append("ObservationRequest.Question.QuestionBankId", observationRequest_Question_QuestionBankId.toString());
        if (observationRequest_Question_QuizAttemptId !== null && observationRequest_Question_QuizAttemptId !== undefined)
            content_.append("ObservationRequest.Question.QuizAttemptId", observationRequest_Question_QuizAttemptId.toString());
        if (observationRequest_Question_DisciplineId !== null && observationRequest_Question_DisciplineId !== undefined)
            content_.append("ObservationRequest.Question.DisciplineId", observationRequest_Question_DisciplineId.toString());
        if (observationRequest_Question_Alternatives !== null && observationRequest_Question_Alternatives !== undefined)
            observationRequest_Question_Alternatives.forEach(item_ => content_.append("ObservationRequest.Question.Alternatives", item_.toString()));
        if (observationRequest_Question_Discipline_Id === null || observationRequest_Question_Discipline_Id === undefined)
            throw new Error("The parameter 'observationRequest_Question_Discipline_Id' cannot be null.");
        else
            content_.append("ObservationRequest.Question.Discipline.Id", observationRequest_Question_Discipline_Id.toString());
        if (observationRequest_Question_Discipline_Name === null || observationRequest_Question_Discipline_Name === undefined)
            throw new Error("The parameter 'observationRequest_Question_Discipline_Name' cannot be null.");
        else
            content_.append("ObservationRequest.Question.Discipline.Name", observationRequest_Question_Discipline_Name.toString());
        if (observationRequest_Question_Discipline_Description === null || observationRequest_Question_Discipline_Description === undefined)
            throw new Error("The parameter 'observationRequest_Question_Discipline_Description' cannot be null.");
        else
            content_.append("ObservationRequest.Question.Discipline.Description", observationRequest_Question_Discipline_Description.toString());
        if (observationRequest_Question_Discipline_Image !== null && observationRequest_Question_Discipline_Image !== undefined)
            content_.append("ObservationRequest.Question.Discipline.Image", observationRequest_Question_Discipline_Image.toString());
        if (observationRequest_Question_Discipline_ParentId !== null && observationRequest_Question_Discipline_ParentId !== undefined)
            content_.append("ObservationRequest.Question.Discipline.ParentId", observationRequest_Question_Discipline_ParentId.toString());
        if (observationRequest_Question_IsValid === null || observationRequest_Question_IsValid === undefined)
            throw new Error("The parameter 'observationRequest_Question_IsValid' cannot be null.");
        else
            content_.append("ObservationRequest.Question.IsValid", observationRequest_Question_IsValid.toString());
        if (observationRequest_Question_File !== null && observationRequest_Question_File !== undefined)
            content_.append("ObservationRequest.Question.File", observationRequest_Question_File.data, observationRequest_Question_File.fileName ? observationRequest_Question_File.fileName : "ObservationRequest.Question.File");
        if (observationRequest_ObservationRequestId !== null && observationRequest_ObservationRequestId !== undefined)
            content_.append("ObservationRequest.ObservationRequestId", observationRequest_ObservationRequestId.toString());
        if (observationRequest_ObservationRequest_Id === null || observationRequest_ObservationRequest_Id === undefined)
            throw new Error("The parameter 'observationRequest_ObservationRequest_Id' cannot be null.");
        else
            content_.append("ObservationRequest.ObservationRequest.Id", observationRequest_ObservationRequest_Id.toString());
        if (observationRequest_ObservationRequest_QuestionId !== null && observationRequest_ObservationRequest_QuestionId !== undefined)
            content_.append("ObservationRequest.ObservationRequest.QuestionId", observationRequest_ObservationRequest_QuestionId.toString());
        if (observationRequest_ObservationRequest_Question_Id === null || observationRequest_ObservationRequest_Question_Id === undefined)
            throw new Error("The parameter 'observationRequest_ObservationRequest_Question_Id' cannot be null.");
        else
            content_.append("ObservationRequest.ObservationRequest.Question.Id", observationRequest_ObservationRequest_Question_Id.toString());
        if (observationRequest_ObservationRequest_Question_Year === null || observationRequest_ObservationRequest_Question_Year === undefined)
            throw new Error("The parameter 'observationRequest_ObservationRequest_Question_Year' cannot be null.");
        else
            content_.append("ObservationRequest.ObservationRequest.Question.Year", observationRequest_ObservationRequest_Question_Year.toString());
        if (observationRequest_ObservationRequest_Question_Board === null || observationRequest_ObservationRequest_Question_Board === undefined)
            throw new Error("The parameter 'observationRequest_ObservationRequest_Question_Board' cannot be null.");
        else
            content_.append("ObservationRequest.ObservationRequest.Question.Board", observationRequest_ObservationRequest_Question_Board.toString());
        if (observationRequest_ObservationRequest_Question_Image !== null && observationRequest_ObservationRequest_Question_Image !== undefined)
            content_.append("ObservationRequest.ObservationRequest.Question.Image", observationRequest_ObservationRequest_Question_Image.toString());
        if (observationRequest_ObservationRequest_Question_Text !== null && observationRequest_ObservationRequest_Question_Text !== undefined)
            content_.append("ObservationRequest.ObservationRequest.Question.Text", observationRequest_ObservationRequest_Question_Text.toString());
        if (observationRequest_ObservationRequest_Question_Score === null || observationRequest_ObservationRequest_Question_Score === undefined)
            throw new Error("The parameter 'observationRequest_ObservationRequest_Question_Score' cannot be null.");
        else
            content_.append("ObservationRequest.ObservationRequest.Question.Score", observationRequest_ObservationRequest_Question_Score.toString());
        if (observationRequest_ObservationRequest_Question_Active === null || observationRequest_ObservationRequest_Question_Active === undefined)
            throw new Error("The parameter 'observationRequest_ObservationRequest_Question_Active' cannot be null.");
        else
            content_.append("ObservationRequest.ObservationRequest.Question.Active", observationRequest_ObservationRequest_Question_Active.toString());
        if (observationRequest_ObservationRequest_Question_QuestionNumber !== null && observationRequest_ObservationRequest_Question_QuestionNumber !== undefined)
            content_.append("ObservationRequest.ObservationRequest.Question.QuestionNumber", observationRequest_ObservationRequest_Question_QuestionNumber.toString());
        if (observationRequest_ObservationRequest_Question_InstitutionId !== null && observationRequest_ObservationRequest_Question_InstitutionId !== undefined)
            content_.append("ObservationRequest.ObservationRequest.Question.InstitutionId", observationRequest_ObservationRequest_Question_InstitutionId.toString());
        if (observationRequest_ObservationRequest_Question_QuestionBankId !== null && observationRequest_ObservationRequest_Question_QuestionBankId !== undefined)
            content_.append("ObservationRequest.ObservationRequest.Question.QuestionBankId", observationRequest_ObservationRequest_Question_QuestionBankId.toString());
        if (observationRequest_ObservationRequest_Question_QuizAttemptId !== null && observationRequest_ObservationRequest_Question_QuizAttemptId !== undefined)
            content_.append("ObservationRequest.ObservationRequest.Question.QuizAttemptId", observationRequest_ObservationRequest_Question_QuizAttemptId.toString());
        if (observationRequest_ObservationRequest_Question_DisciplineId !== null && observationRequest_ObservationRequest_Question_DisciplineId !== undefined)
            content_.append("ObservationRequest.ObservationRequest.Question.DisciplineId", observationRequest_ObservationRequest_Question_DisciplineId.toString());
        if (observationRequest_ObservationRequest_Question_Alternatives !== null && observationRequest_ObservationRequest_Question_Alternatives !== undefined)
            observationRequest_ObservationRequest_Question_Alternatives.forEach(item_ => content_.append("ObservationRequest.ObservationRequest.Question.Alternatives", item_.toString()));
        if (observationRequest_ObservationRequest_Question_Discipline_Id === null || observationRequest_ObservationRequest_Question_Discipline_Id === undefined)
            throw new Error("The parameter 'observationRequest_ObservationRequest_Question_Discipline_Id' cannot be null.");
        else
            content_.append("ObservationRequest.ObservationRequest.Question.Discipline.Id", observationRequest_ObservationRequest_Question_Discipline_Id.toString());
        if (observationRequest_ObservationRequest_Question_Discipline_Name === null || observationRequest_ObservationRequest_Question_Discipline_Name === undefined)
            throw new Error("The parameter 'observationRequest_ObservationRequest_Question_Discipline_Name' cannot be null.");
        else
            content_.append("ObservationRequest.ObservationRequest.Question.Discipline.Name", observationRequest_ObservationRequest_Question_Discipline_Name.toString());
        if (observationRequest_ObservationRequest_Question_Discipline_Description === null || observationRequest_ObservationRequest_Question_Discipline_Description === undefined)
            throw new Error("The parameter 'observationRequest_ObservationRequest_Question_Discipline_Description' cannot be null.");
        else
            content_.append("ObservationRequest.ObservationRequest.Question.Discipline.Description", observationRequest_ObservationRequest_Question_Discipline_Description.toString());
        if (observationRequest_ObservationRequest_Question_Discipline_Image !== null && observationRequest_ObservationRequest_Question_Discipline_Image !== undefined)
            content_.append("ObservationRequest.ObservationRequest.Question.Discipline.Image", observationRequest_ObservationRequest_Question_Discipline_Image.toString());
        if (observationRequest_ObservationRequest_Question_Discipline_ParentId !== null && observationRequest_ObservationRequest_Question_Discipline_ParentId !== undefined)
            content_.append("ObservationRequest.ObservationRequest.Question.Discipline.ParentId", observationRequest_ObservationRequest_Question_Discipline_ParentId.toString());
        if (observationRequest_ObservationRequest_Question_IsValid === null || observationRequest_ObservationRequest_Question_IsValid === undefined)
            throw new Error("The parameter 'observationRequest_ObservationRequest_Question_IsValid' cannot be null.");
        else
            content_.append("ObservationRequest.ObservationRequest.Question.IsValid", observationRequest_ObservationRequest_Question_IsValid.toString());
        if (observationRequest_ObservationRequest_Question_File !== null && observationRequest_ObservationRequest_Question_File !== undefined)
            content_.append("ObservationRequest.ObservationRequest.Question.File", observationRequest_ObservationRequest_Question_File.data, observationRequest_ObservationRequest_Question_File.fileName ? observationRequest_ObservationRequest_Question_File.fileName : "ObservationRequest.ObservationRequest.Question.File");
        if (observationRequest_ObservationRequest_ObservationRequestId !== null && observationRequest_ObservationRequest_ObservationRequestId !== undefined)
            content_.append("ObservationRequest.ObservationRequest.ObservationRequestId", observationRequest_ObservationRequest_ObservationRequestId.toString());
        if (observationRequest_ObservationRequest_ObservationRequest !== null && observationRequest_ObservationRequest_ObservationRequest !== undefined)
            content_.append("ObservationRequest.ObservationRequest.ObservationRequest", JSON.stringify(observationRequest_ObservationRequest_ObservationRequest));
        if (observationRequest_ObservationRequest_Text === null || observationRequest_ObservationRequest_Text === undefined)
            throw new Error("The parameter 'observationRequest_ObservationRequest_Text' cannot be null.");
        else
            content_.append("ObservationRequest.ObservationRequest.Text", observationRequest_ObservationRequest_Text.toString());
        if (observationRequest_ObservationRequest_User === null || observationRequest_ObservationRequest_User === undefined)
            throw new Error("The parameter 'observationRequest_ObservationRequest_User' cannot be null.");
        else
            content_.append("ObservationRequest.ObservationRequest.User", observationRequest_ObservationRequest_User.toString());
        if (observationRequest_Text === null || observationRequest_Text === undefined)
            throw new Error("The parameter 'observationRequest_Text' cannot be null.");
        else
            content_.append("ObservationRequest.Text", observationRequest_Text.toString());
        if (observationRequest_User === null || observationRequest_User === undefined)
            throw new Error("The parameter 'observationRequest_User' cannot be null.");
        else
            content_.append("ObservationRequest.User", observationRequest_User.toString());
        if (text === null || text === undefined)
            throw new Error("The parameter 'text' cannot be null.");
        else
            content_.append("Text", text.toString());
        if (user === null || user === undefined)
            throw new Error("The parameter 'user' cannot be null.");
        else
            content_.append("User", user.toString());

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateWithFile(_response);
        });
    }

    protected processUpdateWithFile(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload(file: FileParameter | undefined, fileName: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/observations/upload?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

export class ObservationsRequestClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    create(body: ObservationRequestRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/observations_request";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Get all records of type T
     * @param currentPage (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @param filter (optional) 
     * @return A PagedResult T with queryable holding the items
     */
    getAll(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfObservationRequestResponseDto> {
        let url_ = this.baseUrl + "/api/observations_request?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<PagedResultOfObservationRequestResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfObservationRequestResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfObservationRequestResponseDto>(null as any);
    }

    /**
     * Get a record of type T by id
     * @param id The id of the item
     * @return A item T
     */
    get(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/observations_request/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Delete a record of type T by id
     * @param id The id of the item to be removed
     * @return True on success, false otherwise
     */
    delete(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/observations_request/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Update a record of type T by id
     * @param id The id of the item to be updated
     * @param body The updated body to be saved
     * @return True on success, false otherwise
     */
    update(id: string, body: ObservationRequestRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/observations_request/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    createWithFile(id: string | null | undefined, questionId: string | null | undefined, user: string | null | undefined, resolved: boolean | null | undefined, type: ObservationType | undefined, text: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/observations_request/file";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id !== null && id !== undefined)
            content_.append("Id", id.toString());
        if (questionId !== null && questionId !== undefined)
            content_.append("QuestionId", questionId.toString());
        if (user !== null && user !== undefined)
            content_.append("User", user.toString());
        if (resolved !== null && resolved !== undefined)
            content_.append("Resolved", resolved.toString());
        if (type === null || type === undefined)
            throw new Error("The parameter 'type' cannot be null.");
        else
            content_.append("Type", type.toString());
        if (text === null || text === undefined)
            throw new Error("The parameter 'text' cannot be null.");
        else
            content_.append("Text", text.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateWithFile(_response);
        });
    }

    protected processCreateWithFile(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    updateWithFile(idPath: string, idFormData: string | null | undefined, questionId: string | null | undefined, user: string | null | undefined, resolved: boolean | null | undefined, type: ObservationType | undefined, text: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/observations_request/file";
        if (idPath === undefined || idPath === null)
            throw new Error("The parameter 'idPath' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + idPath));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (idFormData !== null && idFormData !== undefined)
            content_.append("Id", idFormData.toString());
        if (questionId !== null && questionId !== undefined)
            content_.append("QuestionId", questionId.toString());
        if (user !== null && user !== undefined)
            content_.append("User", user.toString());
        if (resolved !== null && resolved !== undefined)
            content_.append("Resolved", resolved.toString());
        if (type === null || type === undefined)
            throw new Error("The parameter 'type' cannot be null.");
        else
            content_.append("Type", type.toString());
        if (text === null || text === undefined)
            throw new Error("The parameter 'text' cannot be null.");
        else
            content_.append("Text", text.toString());

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateWithFile(_response);
        });
    }

    protected processUpdateWithFile(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload(file: FileParameter | undefined, fileName: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/observations_request/upload?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

export class MessagesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    getPublicMessage(signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/messages/public";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPublicMessage(_response);
        });
    }

    protected processGetPublicMessage(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }

    getProtectedMessage(signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/messages/protected";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProtectedMessage(_response);
        });
    }

    protected processGetProtectedMessage(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }

    getAdminMessage(signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/messages/admin";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAdminMessage(_response);
        });
    }

    protected processGetAdminMessage(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }
}

export class QuestionBankClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    /**
     * Get all records of type T
     * @param currentPage (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @param filter (optional) 
     * @return A PagedResult T with queryable holding the items
     */
    getAll(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfQuestionBankResponseDto> {
        let url_ = this.baseUrl + "/api/question_banks?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<PagedResultOfQuestionBankResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfQuestionBankResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfQuestionBankResponseDto>(null as any);
    }

    /**
     * Create a record of type T
     * @param body The RequestDto to create object
     * @return The created item T
     */
    create(body: QuestionBankRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/question_banks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Get a record of type T by id
     * @param id The id of the item
     * @return A item T
     */
    get(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/question_banks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Delete a record of type T by id
     * @param id The id of the item to be removed
     * @return True on success, false otherwise
     */
    delete(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/question_banks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Update a record of type T by id
     * @param id The id of the item to be updated
     * @param body The updated body to be saved
     * @return True on success, false otherwise
     */
    update(id: string, body: QuestionBankRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/question_banks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    createWithFile(id: string | undefined, name: string | undefined, institutionId: string | null | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/question_banks/file";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (institutionId !== null && institutionId !== undefined)
            content_.append("InstitutionId", institutionId.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateWithFile(_response);
        });
    }

    protected processCreateWithFile(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    updateWithFile(idPath: string, idFormData: string | undefined, name: string | undefined, institutionId: string | null | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/question_banks/file";
        if (idPath === undefined || idPath === null)
            throw new Error("The parameter 'idPath' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + idPath));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (idFormData === null || idFormData === undefined)
            throw new Error("The parameter 'idFormData' cannot be null.");
        else
            content_.append("Id", idFormData.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (institutionId !== null && institutionId !== undefined)
            content_.append("InstitutionId", institutionId.toString());

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateWithFile(_response);
        });
    }

    protected processUpdateWithFile(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload(file: FileParameter | undefined, fileName: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/question_banks/upload?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

export class QuestionClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    getMyAnswers(signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/questions/my";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMyAnswers(_response);
        });
    }

    protected processGetMyAnswers(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    answer(body: AnswerRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/questions/answer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAnswer(_response);
        });
    }

    protected processAnswer(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    create(body: QuestionRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/questions/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    update(id: string, body: QuestionRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/questions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Get a record of type T by id
     * @param id The id of the item
     * @return A item T
     */
    get(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/questions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Delete a record of type T by id
     * @param id The id of the item to be removed
     * @return True on success, false otherwise
     */
    delete(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/questions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    boards(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfSelectListItem> {
        let url_ = this.baseUrl + "/api/questions/boards?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBoards(_response);
        });
    }

    protected processBoards(response: Response): Promise<PagedResultOfSelectListItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfSelectListItem.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfSelectListItem>(null as any);
    }

    numbers(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfSelectListItem> {
        let url_ = this.baseUrl + "/api/questions/numbers?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNumbers(_response);
        });
    }

    protected processNumbers(response: Response): Promise<PagedResultOfSelectListItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfSelectListItem.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfSelectListItem>(null as any);
    }

    filter(institutionIds: string[] | null | undefined, boards: string[] | null | undefined, years: number[] | null | undefined, disciplines: string[] | null | undefined, onlyAnswereds: boolean | null | undefined, onlyCorrects: boolean | null | undefined, greatherThan: number | null | undefined, lessThan: number | null | undefined, quantity: number | null | undefined, questionNumber: number | null | undefined, signal?: AbortSignal): Promise<PagedResultOfQuestionRequestDto> {
        let url_ = this.baseUrl + "/api/questions/filter?";
        if (institutionIds !== undefined && institutionIds !== null)
            institutionIds && institutionIds.forEach(item => { url_ += "InstitutionIds=" + encodeURIComponent("" + item) + "&"; });
        if (boards !== undefined && boards !== null)
            boards && boards.forEach(item => { url_ += "Boards=" + encodeURIComponent("" + item) + "&"; });
        if (years !== undefined && years !== null)
            years && years.forEach(item => { url_ += "Years=" + encodeURIComponent("" + item) + "&"; });
        if (disciplines !== undefined && disciplines !== null)
            disciplines && disciplines.forEach(item => { url_ += "Disciplines=" + encodeURIComponent("" + item) + "&"; });
        if (onlyAnswereds !== undefined && onlyAnswereds !== null)
            url_ += "OnlyAnswereds=" + encodeURIComponent("" + onlyAnswereds) + "&";
        if (onlyCorrects !== undefined && onlyCorrects !== null)
            url_ += "OnlyCorrects=" + encodeURIComponent("" + onlyCorrects) + "&";
        if (greatherThan !== undefined && greatherThan !== null)
            url_ += "GreatherThan=" + encodeURIComponent("" + greatherThan) + "&";
        if (lessThan !== undefined && lessThan !== null)
            url_ += "LessThan=" + encodeURIComponent("" + lessThan) + "&";
        if (quantity !== undefined && quantity !== null)
            url_ += "Quantity=" + encodeURIComponent("" + quantity) + "&";
        if (questionNumber !== undefined && questionNumber !== null)
            url_ += "QuestionNumber=" + encodeURIComponent("" + questionNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFilter(_response);
        });
    }

    protected processFilter(response: Response): Promise<PagedResultOfQuestionRequestDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfQuestionRequestDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfQuestionRequestDto>(null as any);
    }

    years(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfSelectListItem> {
        let url_ = this.baseUrl + "/api/questions/years?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processYears(_response);
        });
    }

    protected processYears(response: Response): Promise<PagedResultOfSelectListItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfSelectListItem.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfSelectListItem>(null as any);
    }

    /**
     * Get all records of type T
     * @param currentPage (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @param filter (optional) 
     * @return A PagedResult T with queryable holding the items
     */
    getAll(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfQuestionResponseDto> {
        let url_ = this.baseUrl + "/api/questions?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<PagedResultOfQuestionResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfQuestionResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfQuestionResponseDto>(null as any);
    }

    createWithFile(id: string | undefined, year: number | undefined, board: string | undefined, image: string | null | undefined, text: string | null | undefined, score: number | undefined, active: boolean | undefined, questionNumber: number | null | undefined, institutionId: string | null | undefined, questionBankId: string | null | undefined, quizAttemptId: string | null | undefined, disciplineId: string | null | undefined, alternatives: AlternativeRequestDto[] | null | undefined, discipline_Id: string | undefined, discipline_Name: string | undefined, discipline_Description: string | undefined, discipline_Image: string | null | undefined, discipline_ParentId: string | null | undefined, isValid: boolean | undefined, file: FileParameter | null | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/questions/file";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (year === null || year === undefined)
            throw new Error("The parameter 'year' cannot be null.");
        else
            content_.append("Year", year.toString());
        if (board === null || board === undefined)
            throw new Error("The parameter 'board' cannot be null.");
        else
            content_.append("Board", board.toString());
        if (image !== null && image !== undefined)
            content_.append("Image", image.toString());
        if (text !== null && text !== undefined)
            content_.append("Text", text.toString());
        if (score === null || score === undefined)
            throw new Error("The parameter 'score' cannot be null.");
        else
            content_.append("Score", score.toString());
        if (active === null || active === undefined)
            throw new Error("The parameter 'active' cannot be null.");
        else
            content_.append("Active", active.toString());
        if (questionNumber !== null && questionNumber !== undefined)
            content_.append("QuestionNumber", questionNumber.toString());
        if (institutionId !== null && institutionId !== undefined)
            content_.append("InstitutionId", institutionId.toString());
        if (questionBankId !== null && questionBankId !== undefined)
            content_.append("QuestionBankId", questionBankId.toString());
        if (quizAttemptId !== null && quizAttemptId !== undefined)
            content_.append("QuizAttemptId", quizAttemptId.toString());
        if (disciplineId !== null && disciplineId !== undefined)
            content_.append("DisciplineId", disciplineId.toString());
        if (alternatives !== null && alternatives !== undefined)
            alternatives.forEach(item_ => content_.append("Alternatives", item_.toString()));
        if (discipline_Id === null || discipline_Id === undefined)
            throw new Error("The parameter 'discipline_Id' cannot be null.");
        else
            content_.append("Discipline.Id", discipline_Id.toString());
        if (discipline_Name === null || discipline_Name === undefined)
            throw new Error("The parameter 'discipline_Name' cannot be null.");
        else
            content_.append("Discipline.Name", discipline_Name.toString());
        if (discipline_Description === null || discipline_Description === undefined)
            throw new Error("The parameter 'discipline_Description' cannot be null.");
        else
            content_.append("Discipline.Description", discipline_Description.toString());
        if (discipline_Image !== null && discipline_Image !== undefined)
            content_.append("Discipline.Image", discipline_Image.toString());
        if (discipline_ParentId !== null && discipline_ParentId !== undefined)
            content_.append("Discipline.ParentId", discipline_ParentId.toString());
        if (isValid === null || isValid === undefined)
            throw new Error("The parameter 'isValid' cannot be null.");
        else
            content_.append("IsValid", isValid.toString());
        if (file !== null && file !== undefined)
            content_.append("File", file.data, file.fileName ? file.fileName : "File");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateWithFile(_response);
        });
    }

    protected processCreateWithFile(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    updateWithFile(idPath: string, idFormData: string | undefined, year: number | undefined, board: string | undefined, image: string | null | undefined, text: string | null | undefined, score: number | undefined, active: boolean | undefined, questionNumber: number | null | undefined, institutionId: string | null | undefined, questionBankId: string | null | undefined, quizAttemptId: string | null | undefined, disciplineId: string | null | undefined, alternatives: AlternativeRequestDto[] | null | undefined, discipline_Id: string | undefined, discipline_Name: string | undefined, discipline_Description: string | undefined, discipline_Image: string | null | undefined, discipline_ParentId: string | null | undefined, isValid: boolean | undefined, file: FileParameter | null | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/questions/file";
        if (idPath === undefined || idPath === null)
            throw new Error("The parameter 'idPath' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + idPath));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (idFormData === null || idFormData === undefined)
            throw new Error("The parameter 'idFormData' cannot be null.");
        else
            content_.append("Id", idFormData.toString());
        if (year === null || year === undefined)
            throw new Error("The parameter 'year' cannot be null.");
        else
            content_.append("Year", year.toString());
        if (board === null || board === undefined)
            throw new Error("The parameter 'board' cannot be null.");
        else
            content_.append("Board", board.toString());
        if (image !== null && image !== undefined)
            content_.append("Image", image.toString());
        if (text !== null && text !== undefined)
            content_.append("Text", text.toString());
        if (score === null || score === undefined)
            throw new Error("The parameter 'score' cannot be null.");
        else
            content_.append("Score", score.toString());
        if (active === null || active === undefined)
            throw new Error("The parameter 'active' cannot be null.");
        else
            content_.append("Active", active.toString());
        if (questionNumber !== null && questionNumber !== undefined)
            content_.append("QuestionNumber", questionNumber.toString());
        if (institutionId !== null && institutionId !== undefined)
            content_.append("InstitutionId", institutionId.toString());
        if (questionBankId !== null && questionBankId !== undefined)
            content_.append("QuestionBankId", questionBankId.toString());
        if (quizAttemptId !== null && quizAttemptId !== undefined)
            content_.append("QuizAttemptId", quizAttemptId.toString());
        if (disciplineId !== null && disciplineId !== undefined)
            content_.append("DisciplineId", disciplineId.toString());
        if (alternatives !== null && alternatives !== undefined)
            alternatives.forEach(item_ => content_.append("Alternatives", item_.toString()));
        if (discipline_Id === null || discipline_Id === undefined)
            throw new Error("The parameter 'discipline_Id' cannot be null.");
        else
            content_.append("Discipline.Id", discipline_Id.toString());
        if (discipline_Name === null || discipline_Name === undefined)
            throw new Error("The parameter 'discipline_Name' cannot be null.");
        else
            content_.append("Discipline.Name", discipline_Name.toString());
        if (discipline_Description === null || discipline_Description === undefined)
            throw new Error("The parameter 'discipline_Description' cannot be null.");
        else
            content_.append("Discipline.Description", discipline_Description.toString());
        if (discipline_Image !== null && discipline_Image !== undefined)
            content_.append("Discipline.Image", discipline_Image.toString());
        if (discipline_ParentId !== null && discipline_ParentId !== undefined)
            content_.append("Discipline.ParentId", discipline_ParentId.toString());
        if (isValid === null || isValid === undefined)
            throw new Error("The parameter 'isValid' cannot be null.");
        else
            content_.append("IsValid", isValid.toString());
        if (file !== null && file !== undefined)
            content_.append("File", file.data, file.fileName ? file.fileName : "File");

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateWithFile(_response);
        });
    }

    protected processUpdateWithFile(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload(file: FileParameter | undefined, fileName: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/questions/upload?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

export class QuizAttemptConfigurationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    getAll(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfQuizAttemptConfigurationResponseDto> {
        let url_ = this.baseUrl + "/api/quiz_attempt_configs?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<PagedResultOfQuizAttemptConfigurationResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfQuizAttemptConfigurationResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfQuizAttemptConfigurationResponseDto>(null as any);
    }

    create(body: QuizAttemptConfigurationRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/quiz_attempt_configs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Get a record of type T by id
     * @param id The id of the item
     * @return A item T
     */
    get(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/quiz_attempt_configs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Delete a record of type T by id
     * @param id The id of the item to be removed
     * @return True on success, false otherwise
     */
    delete(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/quiz_attempt_configs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Update a record of type T by id
     * @param id The id of the item to be updated
     * @param body The updated body to be saved
     * @return True on success, false otherwise
     */
    update(id: string, body: QuizAttemptConfigurationRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/quiz_attempt_configs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    createWithFile(id: string | null | undefined, name: string | undefined, image: string | null | undefined, user: string | null | undefined, description: string | null | undefined, boards: string[] | null | undefined, years: number[] | null | undefined, institutions: string[] | null | undefined, disciplines: string[] | null | undefined, random: boolean | null | undefined, onlyNotAnswered: boolean | null | undefined, onlyWrongs: boolean | null | undefined, active: boolean | undefined, showOnFront: boolean | undefined, users: string[] | null | undefined, usersCount: number | undefined, userIds: string | null | undefined, crews: CrewRequestDto[] | null | undefined, crewsCount: number | undefined, crewsIds: string | null | undefined, questions: QuestionRequestDto[] | null | undefined, questionsCount: number | undefined, questionsIds: string | null | undefined, data: string | null | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/quiz_attempt_configs/file";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id !== null && id !== undefined)
            content_.append("Id", id.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (image !== null && image !== undefined)
            content_.append("Image", image.toString());
        if (user !== null && user !== undefined)
            content_.append("User", user.toString());
        if (description !== null && description !== undefined)
            content_.append("Description", description.toString());
        if (boards !== null && boards !== undefined)
            boards.forEach(item_ => content_.append("Boards", item_.toString()));
        if (years !== null && years !== undefined)
            years.forEach(item_ => content_.append("Years", item_.toString()));
        if (institutions !== null && institutions !== undefined)
            institutions.forEach(item_ => content_.append("Institutions", item_.toString()));
        if (disciplines !== null && disciplines !== undefined)
            disciplines.forEach(item_ => content_.append("Disciplines", item_.toString()));
        if (random !== null && random !== undefined)
            content_.append("Random", random.toString());
        if (onlyNotAnswered !== null && onlyNotAnswered !== undefined)
            content_.append("OnlyNotAnswered", onlyNotAnswered.toString());
        if (onlyWrongs !== null && onlyWrongs !== undefined)
            content_.append("OnlyWrongs", onlyWrongs.toString());
        if (active === null || active === undefined)
            throw new Error("The parameter 'active' cannot be null.");
        else
            content_.append("Active", active.toString());
        if (showOnFront === null || showOnFront === undefined)
            throw new Error("The parameter 'showOnFront' cannot be null.");
        else
            content_.append("ShowOnFront", showOnFront.toString());
        if (users !== null && users !== undefined)
            users.forEach(item_ => content_.append("Users", item_.toString()));
        if (usersCount === null || usersCount === undefined)
            throw new Error("The parameter 'usersCount' cannot be null.");
        else
            content_.append("UsersCount", usersCount.toString());
        if (userIds !== null && userIds !== undefined)
            content_.append("UserIds", userIds.toString());
        if (crews !== null && crews !== undefined)
            crews.forEach(item_ => content_.append("Crews", item_.toString()));
        if (crewsCount === null || crewsCount === undefined)
            throw new Error("The parameter 'crewsCount' cannot be null.");
        else
            content_.append("CrewsCount", crewsCount.toString());
        if (crewsIds !== null && crewsIds !== undefined)
            content_.append("CrewsIds", crewsIds.toString());
        if (questions !== null && questions !== undefined)
            questions.forEach(item_ => content_.append("Questions", item_.toString()));
        if (questionsCount === null || questionsCount === undefined)
            throw new Error("The parameter 'questionsCount' cannot be null.");
        else
            content_.append("QuestionsCount", questionsCount.toString());
        if (questionsIds !== null && questionsIds !== undefined)
            content_.append("QuestionsIds", questionsIds.toString());
        if (data !== null && data !== undefined)
            content_.append("Data", data.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateWithFile(_response);
        });
    }

    protected processCreateWithFile(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    updateWithFile(idPath: string, idFormData: string | null | undefined, name: string | undefined, image: string | null | undefined, user: string | null | undefined, description: string | null | undefined, boards: string[] | null | undefined, years: number[] | null | undefined, institutions: string[] | null | undefined, disciplines: string[] | null | undefined, random: boolean | null | undefined, onlyNotAnswered: boolean | null | undefined, onlyWrongs: boolean | null | undefined, active: boolean | undefined, showOnFront: boolean | undefined, users: string[] | null | undefined, usersCount: number | undefined, userIds: string | null | undefined, crews: CrewRequestDto[] | null | undefined, crewsCount: number | undefined, crewsIds: string | null | undefined, questions: QuestionRequestDto[] | null | undefined, questionsCount: number | undefined, questionsIds: string | null | undefined, data: string | null | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/quiz_attempt_configs/file";
        if (idPath === undefined || idPath === null)
            throw new Error("The parameter 'idPath' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + idPath));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (idFormData !== null && idFormData !== undefined)
            content_.append("Id", idFormData.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (image !== null && image !== undefined)
            content_.append("Image", image.toString());
        if (user !== null && user !== undefined)
            content_.append("User", user.toString());
        if (description !== null && description !== undefined)
            content_.append("Description", description.toString());
        if (boards !== null && boards !== undefined)
            boards.forEach(item_ => content_.append("Boards", item_.toString()));
        if (years !== null && years !== undefined)
            years.forEach(item_ => content_.append("Years", item_.toString()));
        if (institutions !== null && institutions !== undefined)
            institutions.forEach(item_ => content_.append("Institutions", item_.toString()));
        if (disciplines !== null && disciplines !== undefined)
            disciplines.forEach(item_ => content_.append("Disciplines", item_.toString()));
        if (random !== null && random !== undefined)
            content_.append("Random", random.toString());
        if (onlyNotAnswered !== null && onlyNotAnswered !== undefined)
            content_.append("OnlyNotAnswered", onlyNotAnswered.toString());
        if (onlyWrongs !== null && onlyWrongs !== undefined)
            content_.append("OnlyWrongs", onlyWrongs.toString());
        if (active === null || active === undefined)
            throw new Error("The parameter 'active' cannot be null.");
        else
            content_.append("Active", active.toString());
        if (showOnFront === null || showOnFront === undefined)
            throw new Error("The parameter 'showOnFront' cannot be null.");
        else
            content_.append("ShowOnFront", showOnFront.toString());
        if (users !== null && users !== undefined)
            users.forEach(item_ => content_.append("Users", item_.toString()));
        if (usersCount === null || usersCount === undefined)
            throw new Error("The parameter 'usersCount' cannot be null.");
        else
            content_.append("UsersCount", usersCount.toString());
        if (userIds !== null && userIds !== undefined)
            content_.append("UserIds", userIds.toString());
        if (crews !== null && crews !== undefined)
            crews.forEach(item_ => content_.append("Crews", item_.toString()));
        if (crewsCount === null || crewsCount === undefined)
            throw new Error("The parameter 'crewsCount' cannot be null.");
        else
            content_.append("CrewsCount", crewsCount.toString());
        if (crewsIds !== null && crewsIds !== undefined)
            content_.append("CrewsIds", crewsIds.toString());
        if (questions !== null && questions !== undefined)
            questions.forEach(item_ => content_.append("Questions", item_.toString()));
        if (questionsCount === null || questionsCount === undefined)
            throw new Error("The parameter 'questionsCount' cannot be null.");
        else
            content_.append("QuestionsCount", questionsCount.toString());
        if (questionsIds !== null && questionsIds !== undefined)
            content_.append("QuestionsIds", questionsIds.toString());
        if (data !== null && data !== undefined)
            content_.append("Data", data.toString());

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateWithFile(_response);
        });
    }

    protected processUpdateWithFile(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload(file: FileParameter | undefined, fileName: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/quiz_attempt_configs/upload?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

export class UserClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    getPermissions(id: string, paginationInfo: PaginationInfo, signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/users/permissions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(paginationInfo);

        let options_: RequestInit = {
            body: content_,
            method: "GET",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPermissions(_response);
        });
    }

    protected processGetPermissions(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }

    addPermission(id: string, permissionsRequest: AssignPermissionsRequest, signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/users/permissions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(permissionsRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddPermission(_response);
        });
    }

    protected processAddPermission(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }

    getRoles(id: string, paginationInfo: PaginationInfo, signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/users/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(paginationInfo);

        let options_: RequestInit = {
            body: content_,
            method: "GET",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRoles(_response);
        });
    }

    protected processGetRoles(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }

    addRole(id: string, rolesRequest: AssignRolesRequest, signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/users/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(rolesRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddRole(_response);
        });
    }

    protected processAddRole(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }

    get(id: string, signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }

    get2(currentPage: number | undefined, pageSize: number | undefined, filter: string | null | undefined, sort: string | null | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/users/all?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "currentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet2(_response);
        });
    }

    protected processGet2(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

/** PagedResult */
export class PagedResult implements IPagedResult {
    /** Gets or sets the queryable. */
    queryable!: Queryable[];
    /** Gets or sets the current page. */
    currentPage!: number;
    /** Gets or sets the page count. */
    pageCount!: number;
    /** Gets or sets the size of the page. */
    pageSize!: number;
    /** Gets or sets the row count. */
    rowCount!: number;

    constructor(data?: IPagedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.queryable = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(item);
            }
            this.currentPage = _data["currentPage"];
            this.pageCount = _data["pageCount"];
            this.pageSize = _data["pageSize"];
            this.rowCount = _data["rowCount"];
        }
    }

    static fromJS(data: any): PagedResult {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item);
        }
        data["currentPage"] = this.currentPage;
        data["pageCount"] = this.pageCount;
        data["pageSize"] = this.pageSize;
        data["rowCount"] = this.rowCount;
        return data;
    }
}

/** PagedResult */
export interface IPagedResult {
    /** Gets or sets the queryable. */
    queryable: Queryable[];
    /** Gets or sets the current page. */
    currentPage: number;
    /** Gets or sets the page count. */
    pageCount: number;
    /** Gets or sets the size of the page. */
    pageSize: number;
    /** Gets or sets the row count. */
    rowCount: number;
}

/** PagedResult{TSource} */
export class PagedResultOfAnswerResponseDto extends PagedResult implements IPagedResultOfAnswerResponseDto {
    queryable!: AnswerResponseDto[];

    constructor(data?: IPagedResultOfAnswerResponseDto) {
        super(data);
        if (!data) {
            this.queryable = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(AnswerResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PagedResultOfAnswerResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfAnswerResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** PagedResult{TSource} */
export interface IPagedResultOfAnswerResponseDto extends IPagedResult {
    queryable: AnswerResponseDto[];
}

export class AnswerRequestDto implements IAnswerRequestDto {
    id!: string;
    questionId?: string | undefined;
    user?: string | undefined;
    alternativeId?: string | undefined;
    correct!: boolean;
    quizAttemptId?: string | undefined;

    constructor(data?: IAnswerRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.questionId = _data["questionId"];
            this.user = _data["user"];
            this.alternativeId = _data["alternativeId"];
            this.correct = _data["correct"];
            this.quizAttemptId = _data["quizAttemptId"];
        }
    }

    static fromJS(data: any): AnswerRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new AnswerRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionId"] = this.questionId;
        data["user"] = this.user;
        data["alternativeId"] = this.alternativeId;
        data["correct"] = this.correct;
        data["quizAttemptId"] = this.quizAttemptId;
        return data;
    }
}

export interface IAnswerRequestDto {
    id: string;
    questionId?: string | undefined;
    user?: string | undefined;
    alternativeId?: string | undefined;
    correct: boolean;
    quizAttemptId?: string | undefined;
}

export class AnswerResponseDto extends AnswerRequestDto implements IAnswerResponseDto {
    question?: QuestionResponseDto | undefined;
    alternative?: AlternativeResponseDto | undefined;
    quizAttempt?: QuizAttemptResponseDto | undefined;

    constructor(data?: IAnswerResponseDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.question = _data["question"] ? QuestionResponseDto.fromJS(_data["question"]) : <any>undefined;
            this.alternative = _data["alternative"] ? AlternativeResponseDto.fromJS(_data["alternative"]) : <any>undefined;
            this.quizAttempt = _data["quizAttempt"] ? QuizAttemptResponseDto.fromJS(_data["quizAttempt"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): AnswerResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new AnswerResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["question"] = this.question ? this.question.toJSON() : <any>undefined;
        data["alternative"] = this.alternative ? this.alternative.toJSON() : <any>undefined;
        data["quizAttempt"] = this.quizAttempt ? this.quizAttempt.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IAnswerResponseDto extends IAnswerRequestDto {
    question?: QuestionResponseDto | undefined;
    alternative?: AlternativeResponseDto | undefined;
    quizAttempt?: QuizAttemptResponseDto | undefined;
}

export class HasFile implements IHasFile {
    file?: any | undefined;

    constructor(data?: IHasFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.file = _data["file"];
        }
    }

    static fromJS(data: any): HasFile {
        data = typeof data === 'object' ? data : {};
        let result = new HasFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["file"] = this.file;
        return data;
    }
}

export interface IHasFile {
    file?: any | undefined;
}

export class QuestionRequestDto extends HasFile implements IQuestionRequestDto {
    id!: string;
    year!: number;
    board!: string;
    image?: string | undefined;
    text?: string | undefined;
    score!: number;
    active!: boolean;
    questionNumber?: number | undefined;
    institutionId?: string | undefined;
    questionBankId?: string | undefined;
    quizAttemptId?: string | undefined;
    disciplineId?: string | undefined;
    alternatives?: AlternativeRequestDto[] | undefined;
    discipline?: DisciplineRequestDto | undefined;
    isValid!: boolean;

    constructor(data?: IQuestionRequestDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.year = _data["year"];
            this.board = _data["board"];
            this.image = _data["image"];
            this.text = _data["text"];
            this.score = _data["score"];
            this.active = _data["active"];
            this.questionNumber = _data["questionNumber"];
            this.institutionId = _data["institutionId"];
            this.questionBankId = _data["questionBankId"];
            this.quizAttemptId = _data["quizAttemptId"];
            this.disciplineId = _data["disciplineId"];
            if (Array.isArray(_data["alternatives"])) {
                this.alternatives = [] as any;
                for (let item of _data["alternatives"])
                    this.alternatives!.push(AlternativeRequestDto.fromJS(item));
            }
            this.discipline = _data["discipline"] ? DisciplineRequestDto.fromJS(_data["discipline"]) : <any>undefined;
            this.isValid = _data["isValid"];
        }
    }

    static override fromJS(data: any): QuestionRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionRequestDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["year"] = this.year;
        data["board"] = this.board;
        data["image"] = this.image;
        data["text"] = this.text;
        data["score"] = this.score;
        data["active"] = this.active;
        data["questionNumber"] = this.questionNumber;
        data["institutionId"] = this.institutionId;
        data["questionBankId"] = this.questionBankId;
        data["quizAttemptId"] = this.quizAttemptId;
        data["disciplineId"] = this.disciplineId;
        if (Array.isArray(this.alternatives)) {
            data["alternatives"] = [];
            for (let item of this.alternatives)
                data["alternatives"].push(item.toJSON());
        }
        data["discipline"] = this.discipline ? this.discipline.toJSON() : <any>undefined;
        data["isValid"] = this.isValid;
        super.toJSON(data);
        return data;
    }
}

export interface IQuestionRequestDto extends IHasFile {
    id: string;
    year: number;
    board: string;
    image?: string | undefined;
    text?: string | undefined;
    score: number;
    active: boolean;
    questionNumber?: number | undefined;
    institutionId?: string | undefined;
    questionBankId?: string | undefined;
    quizAttemptId?: string | undefined;
    disciplineId?: string | undefined;
    alternatives?: AlternativeRequestDto[] | undefined;
    discipline?: DisciplineRequestDto | undefined;
    isValid: boolean;
}

export class QuestionResponseDto extends QuestionRequestDto implements IQuestionResponseDto {
    alternatives!: AlternativeResponseDto[];
    observations!: ObservationResponseDto[];
    answers!: AnswerResponseDto[];
    observationRequests!: ObservationRequestResponseDto[];
    discipline!: DisciplineResponseDto;
    questionNumber!: number;
    disciplineName!: string;
    institutionName!: string;
    alternativesCount!: number;
    observationsCount!: number;
    answersCount!: number;
    observationRequestsCount!: number;

    constructor(data?: IQuestionResponseDto) {
        super(data);
        if (!data) {
            this.alternatives = [];
            this.observations = [];
            this.answers = [];
            this.observationRequests = [];
            this.discipline = new DisciplineResponseDto();
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["alternatives"])) {
                this.alternatives = [] as any;
                for (let item of _data["alternatives"])
                    this.alternatives!.push(AlternativeResponseDto.fromJS(item));
            }
            if (Array.isArray(_data["observations"])) {
                this.observations = [] as any;
                for (let item of _data["observations"])
                    this.observations!.push(ObservationResponseDto.fromJS(item));
            }
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(AnswerResponseDto.fromJS(item));
            }
            if (Array.isArray(_data["observationRequests"])) {
                this.observationRequests = [] as any;
                for (let item of _data["observationRequests"])
                    this.observationRequests!.push(ObservationRequestResponseDto.fromJS(item));
            }
            this.discipline = _data["discipline"] ? DisciplineResponseDto.fromJS(_data["discipline"]) : new DisciplineResponseDto();
            this.questionNumber = _data["questionNumber"];
            this.disciplineName = _data["disciplineName"];
            this.institutionName = _data["institutionName"];
            this.alternativesCount = _data["alternativesCount"];
            this.observationsCount = _data["observationsCount"];
            this.answersCount = _data["answersCount"];
            this.observationRequestsCount = _data["observationRequestsCount"];
        }
    }

    static override fromJS(data: any): QuestionResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.alternatives)) {
            data["alternatives"] = [];
            for (let item of this.alternatives)
                data["alternatives"].push(item.toJSON());
        }
        if (Array.isArray(this.observations)) {
            data["observations"] = [];
            for (let item of this.observations)
                data["observations"].push(item.toJSON());
        }
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        if (Array.isArray(this.observationRequests)) {
            data["observationRequests"] = [];
            for (let item of this.observationRequests)
                data["observationRequests"].push(item.toJSON());
        }
        data["discipline"] = this.discipline ? this.discipline.toJSON() : <any>undefined;
        data["questionNumber"] = this.questionNumber;
        data["disciplineName"] = this.disciplineName;
        data["institutionName"] = this.institutionName;
        data["alternativesCount"] = this.alternativesCount;
        data["observationsCount"] = this.observationsCount;
        data["answersCount"] = this.answersCount;
        data["observationRequestsCount"] = this.observationRequestsCount;
        super.toJSON(data);
        return data;
    }
}

export interface IQuestionResponseDto extends IQuestionRequestDto {
    alternatives: AlternativeResponseDto[];
    observations: ObservationResponseDto[];
    answers: AnswerResponseDto[];
    observationRequests: ObservationRequestResponseDto[];
    discipline: DisciplineResponseDto;
    questionNumber: number;
    disciplineName: string;
    institutionName: string;
    alternativesCount: number;
    observationsCount: number;
    answersCount: number;
    observationRequestsCount: number;
}

export class AlternativeResponseDto implements IAlternativeResponseDto {
    id?: string | undefined;
    questionId?: string | undefined;
    text!: string;
    aiExplanation!: string;
    question?: QuestionResponseDto | undefined;
    questionText!: string;
    answers!: AnswerResponseDto[];
    answersCount!: number;

    constructor(data?: IAlternativeResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.answers = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.questionId = _data["questionId"];
            this.text = _data["text"];
            this.aiExplanation = _data["aiExplanation"];
            this.question = _data["question"] ? QuestionResponseDto.fromJS(_data["question"]) : <any>undefined;
            this.questionText = _data["questionText"];
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(AnswerResponseDto.fromJS(item));
            }
            this.answersCount = _data["answersCount"];
        }
    }

    static fromJS(data: any): AlternativeResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlternativeResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionId"] = this.questionId;
        data["text"] = this.text;
        data["aiExplanation"] = this.aiExplanation;
        data["question"] = this.question ? this.question.toJSON() : <any>undefined;
        data["questionText"] = this.questionText;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        data["answersCount"] = this.answersCount;
        return data;
    }
}

export interface IAlternativeResponseDto {
    id?: string | undefined;
    questionId?: string | undefined;
    text: string;
    aiExplanation: string;
    question?: QuestionResponseDto | undefined;
    questionText: string;
    answers: AnswerResponseDto[];
    answersCount: number;
}

export class ObservationRequestDto implements IObservationRequestDto {
    id!: string;
    questionId?: string | undefined;
    question?: QuestionRequestDto | undefined;
    observationRequestId?: string | undefined;
    observationRequest?: ObservationRequestDto | undefined;
    text!: string;
    user!: string;

    constructor(data?: IObservationRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.questionId = _data["questionId"];
            this.question = _data["question"] ? QuestionRequestDto.fromJS(_data["question"]) : <any>undefined;
            this.observationRequestId = _data["observationRequestId"];
            this.observationRequest = _data["observationRequest"] ? ObservationRequestDto.fromJS(_data["observationRequest"]) : <any>undefined;
            this.text = _data["text"];
            this.user = _data["user"];
        }
    }

    static fromJS(data: any): ObservationRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObservationRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionId"] = this.questionId;
        data["question"] = this.question ? this.question.toJSON() : <any>undefined;
        data["observationRequestId"] = this.observationRequestId;
        data["observationRequest"] = this.observationRequest ? this.observationRequest.toJSON() : <any>undefined;
        data["text"] = this.text;
        data["user"] = this.user;
        return data;
    }
}

export interface IObservationRequestDto {
    id: string;
    questionId?: string | undefined;
    question?: QuestionRequestDto | undefined;
    observationRequestId?: string | undefined;
    observationRequest?: ObservationRequestDto | undefined;
    text: string;
    user: string;
}

export class ObservationResponseDto extends ObservationRequestDto implements IObservationResponseDto {
    question?: QuestionResponseDto | undefined;

    constructor(data?: IObservationResponseDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.question = _data["question"] ? QuestionResponseDto.fromJS(_data["question"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ObservationResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObservationResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["question"] = this.question ? this.question.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IObservationResponseDto extends IObservationRequestDto {
    question?: QuestionResponseDto | undefined;
}

export class AlternativeRequestDto implements IAlternativeRequestDto {
    id?: string | undefined;
    questionId?: string | undefined;
    text!: string;
    correct!: boolean;
    aiExplanation!: string;

    constructor(data?: IAlternativeRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.questionId = _data["questionId"];
            this.text = _data["text"];
            this.correct = _data["correct"];
            this.aiExplanation = _data["aiExplanation"];
        }
    }

    static fromJS(data: any): AlternativeRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlternativeRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionId"] = this.questionId;
        data["text"] = this.text;
        data["correct"] = this.correct;
        data["aiExplanation"] = this.aiExplanation;
        return data;
    }
}

export interface IAlternativeRequestDto {
    id?: string | undefined;
    questionId?: string | undefined;
    text: string;
    correct: boolean;
    aiExplanation: string;
}

export class DisciplineRequestDto implements IDisciplineRequestDto {
    id!: string;
    name!: string;
    description!: string;
    image?: string | undefined;
    parentId?: string | undefined;

    constructor(data?: IDisciplineRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.image = _data["image"];
            this.parentId = _data["parentId"];
        }
    }

    static fromJS(data: any): DisciplineRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new DisciplineRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["image"] = this.image;
        data["parentId"] = this.parentId;
        return data;
    }
}

export interface IDisciplineRequestDto {
    id: string;
    name: string;
    description: string;
    image?: string | undefined;
    parentId?: string | undefined;
}

export class ObservationRequestRequestDto implements IObservationRequestRequestDto {
    id?: string | undefined;
    questionId?: string | undefined;
    user?: string | undefined;
    resolved?: boolean | undefined;
    type!: ObservationType;
    text!: string;

    constructor(data?: IObservationRequestRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.questionId = _data["questionId"];
            this.user = _data["user"];
            this.resolved = _data["resolved"];
            this.type = _data["type"];
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): ObservationRequestRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObservationRequestRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionId"] = this.questionId;
        data["user"] = this.user;
        data["resolved"] = this.resolved;
        data["type"] = this.type;
        data["text"] = this.text;
        return data;
    }
}

export interface IObservationRequestRequestDto {
    id?: string | undefined;
    questionId?: string | undefined;
    user?: string | undefined;
    resolved?: boolean | undefined;
    type: ObservationType;
    text: string;
}

export class ObservationRequestResponseDto extends ObservationRequestRequestDto implements IObservationRequestResponseDto {
    question?: QuestionRequestDto | undefined;

    constructor(data?: IObservationRequestResponseDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.question = _data["question"] ? QuestionRequestDto.fromJS(_data["question"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ObservationRequestResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObservationRequestResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["question"] = this.question ? this.question.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IObservationRequestResponseDto extends IObservationRequestRequestDto {
    question?: QuestionRequestDto | undefined;
}

export type ObservationType = 0 | 1;

export class DisciplineResponseDto extends DisciplineRequestDto implements IDisciplineResponseDto {
    parentName!: string;
    childsCount!: number;
    parent?: DisciplineResponseDto | undefined;
    childs!: DisciplineResponseDto[];
    questions!: QuestionResponseDto[];

    constructor(data?: IDisciplineResponseDto) {
        super(data);
        if (!data) {
            this.childs = [];
            this.questions = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.parentName = _data["parentName"];
            this.childsCount = _data["childsCount"];
            this.parent = _data["parent"] ? DisciplineResponseDto.fromJS(_data["parent"]) : <any>undefined;
            if (Array.isArray(_data["childs"])) {
                this.childs = [] as any;
                for (let item of _data["childs"])
                    this.childs!.push(DisciplineResponseDto.fromJS(item));
            }
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(QuestionResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): DisciplineResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new DisciplineResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["childsCount"] = this.childsCount;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        if (Array.isArray(this.childs)) {
            data["childs"] = [];
            for (let item of this.childs)
                data["childs"].push(item.toJSON());
        }
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IDisciplineResponseDto extends IDisciplineRequestDto {
    parentName: string;
    childsCount: number;
    parent?: DisciplineResponseDto | undefined;
    childs: DisciplineResponseDto[];
    questions: QuestionResponseDto[];
}

export class QuizAttemptRequestDto implements IQuizAttemptRequestDto {
    id!: string;
    user!: string;
    startedAt!: Date;
    finishedAt?: Date | undefined;
    dConfigureServicesuration?: string | undefined;
    score!: number;
    total!: number;
    passed!: boolean;

    constructor(data?: IQuizAttemptRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user = _data["user"];
            this.startedAt = _data["startedAt"] ? new Date(_data["startedAt"].toString()) : <any>undefined;
            this.finishedAt = _data["finishedAt"] ? new Date(_data["finishedAt"].toString()) : <any>undefined;
            this.dConfigureServicesuration = _data["dConfigureServicesuration"];
            this.score = _data["score"];
            this.total = _data["total"];
            this.passed = _data["passed"];
        }
    }

    static fromJS(data: any): QuizAttemptRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuizAttemptRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user"] = this.user;
        data["startedAt"] = this.startedAt ? this.startedAt.toISOString() : <any>undefined;
        data["finishedAt"] = this.finishedAt ? this.finishedAt.toISOString() : <any>undefined;
        data["dConfigureServicesuration"] = this.dConfigureServicesuration;
        data["score"] = this.score;
        data["total"] = this.total;
        data["passed"] = this.passed;
        return data;
    }
}

export interface IQuizAttemptRequestDto {
    id: string;
    user: string;
    startedAt: Date;
    finishedAt?: Date | undefined;
    dConfigureServicesuration?: string | undefined;
    score: number;
    total: number;
    passed: boolean;
}

export class QuizAttemptResponseDto extends QuizAttemptRequestDto implements IQuizAttemptResponseDto {
    questions!: QuestionResponseDto[];
    answers!: AnswerResponseDto[];

    constructor(data?: IQuizAttemptResponseDto) {
        super(data);
        if (!data) {
            this.questions = [];
            this.answers = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(QuestionResponseDto.fromJS(item));
            }
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(AnswerResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): QuizAttemptResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuizAttemptResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IQuizAttemptResponseDto extends IQuizAttemptRequestDto {
    questions: QuestionResponseDto[];
    answers: AnswerResponseDto[];
}

export class Message implements IMessage {
    text?: string | undefined;

    constructor(data?: IMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): Message {
        data = typeof data === 'object' ? data : {};
        let result = new Message();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        return data;
    }
}

export interface IMessage {
    text?: string | undefined;
}

/** Contains common elements used for both constructing User-related requests, and comprising User-related responses. */
export abstract class UserBase implements IUserBase {
    /** Contains user meta data. The user has read-only access to this. */
    app_metadata?: any | undefined;
    /** Gets or sets the user's email address. */
    email?: string | undefined;
    /** Gets or sets whether the user's email address is verified. */
    email_verified?: boolean | undefined;
    /** Gets or sets the user's phone number. */
    phone_number?: string | undefined;
    /** Gets or sets whether the user's phone is verified. */
    phone_verified?: boolean | undefined;
    /** Contains user meta data. The user has read/write access to this. */
    user_metadata?: any | undefined;
    /** Gets or sets the user' username. */
    username?: string | undefined;
    /** The Nickname of the user. */
    nickname?: string | undefined;
    /** The first name of the user (if available). */
    given_name?: string | undefined;
    /** The full name of the user (e.g.: John Foo). ALWAYS GENERATED. */
    name?: string | undefined;
    /** The last name of the user (if available). */
    family_name?: string | undefined;
    /** URL pointing to the user picture (if not available, will use gravatar.com with the email). ALWAYS GENERATED */
    picture?: string | undefined;
    /** Gets or sets whether the user is blocked. True if the user is blocked, otherwise false. */
    blocked?: boolean | undefined;

    constructor(data?: IUserBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.app_metadata = _data["app_metadata"];
            this.email = _data["email"];
            this.email_verified = _data["email_verified"];
            this.phone_number = _data["phone_number"];
            this.phone_verified = _data["phone_verified"];
            this.user_metadata = _data["user_metadata"];
            this.username = _data["username"];
            this.nickname = _data["nickname"];
            this.given_name = _data["given_name"];
            this.name = _data["name"];
            this.family_name = _data["family_name"];
            this.picture = _data["picture"];
            this.blocked = _data["blocked"];
        }
    }

    static fromJS(data: any): UserBase {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'UserBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["app_metadata"] = this.app_metadata;
        data["email"] = this.email;
        data["email_verified"] = this.email_verified;
        data["phone_number"] = this.phone_number;
        data["phone_verified"] = this.phone_verified;
        data["user_metadata"] = this.user_metadata;
        data["username"] = this.username;
        data["nickname"] = this.nickname;
        data["given_name"] = this.given_name;
        data["name"] = this.name;
        data["family_name"] = this.family_name;
        data["picture"] = this.picture;
        data["blocked"] = this.blocked;
        return data;
    }
}

/** Contains common elements used for both constructing User-related requests, and comprising User-related responses. */
export interface IUserBase {
    /** Contains user meta data. The user has read-only access to this. */
    app_metadata?: any | undefined;
    /** Gets or sets the user's email address. */
    email?: string | undefined;
    /** Gets or sets whether the user's email address is verified. */
    email_verified?: boolean | undefined;
    /** Gets or sets the user's phone number. */
    phone_number?: string | undefined;
    /** Gets or sets whether the user's phone is verified. */
    phone_verified?: boolean | undefined;
    /** Contains user meta data. The user has read/write access to this. */
    user_metadata?: any | undefined;
    /** Gets or sets the user' username. */
    username?: string | undefined;
    /** The Nickname of the user. */
    nickname?: string | undefined;
    /** The first name of the user (if available). */
    given_name?: string | undefined;
    /** The full name of the user (e.g.: John Foo). ALWAYS GENERATED. */
    name?: string | undefined;
    /** The last name of the user (if available). */
    family_name?: string | undefined;
    /** URL pointing to the user picture (if not available, will use gravatar.com with the email). ALWAYS GENERATED */
    picture?: string | undefined;
    /** Gets or sets whether the user is blocked. True if the user is blocked, otherwise false. */
    blocked?: boolean | undefined;
}

/** Represents the request to create a User. */
export class UserCreateRequest extends UserBase implements IUserCreateRequest {
    /** Gets or sets the connection the user belongs to. */
    connection?: string | undefined;
    /** Gets or sets the (optional) id of the user */
    user_id?: string | undefined;
    /** Gets or sets the user's password. This is mandatory only for auth0 connection strategy. */
    password?: string | undefined;
    /** Gets or sets whether the user's email change must be verified. True if it must be verified, otherwise false. */
    verify_email?: boolean | undefined;

    constructor(data?: IUserCreateRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.connection = _data["connection"];
            this.user_id = _data["user_id"];
            this.password = _data["password"];
            this.verify_email = _data["verify_email"];
        }
    }

    static override fromJS(data: any): UserCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserCreateRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connection"] = this.connection;
        data["user_id"] = this.user_id;
        data["password"] = this.password;
        data["verify_email"] = this.verify_email;
        super.toJSON(data);
        return data;
    }
}

/** Represents the request to create a User. */
export interface IUserCreateRequest extends IUserBase {
    /** Gets or sets the connection the user belongs to. */
    connection?: string | undefined;
    /** Gets or sets the (optional) id of the user */
    user_id?: string | undefined;
    /** Gets or sets the user's password. This is mandatory only for auth0 connection strategy. */
    password?: string | undefined;
    /** Gets or sets whether the user's email change must be verified. True if it must be verified, otherwise false. */
    verify_email?: boolean | undefined;
}

/** Base class for user maintenance requests. */
export class UserMaintenanceRequestBase implements IUserMaintenanceRequestBase {
    /** Client ID of the application. */
    client_id?: string | undefined;
    /** Name of the connection. */
    connection?: string | undefined;
    /** Email address of the user. */
    email?: string | undefined;

    constructor(data?: IUserMaintenanceRequestBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.client_id = _data["client_id"];
            this.connection = _data["connection"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): UserMaintenanceRequestBase {
        data = typeof data === 'object' ? data : {};
        let result = new UserMaintenanceRequestBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["client_id"] = this.client_id;
        data["connection"] = this.connection;
        data["email"] = this.email;
        return data;
    }
}

/** Base class for user maintenance requests. */
export interface IUserMaintenanceRequestBase {
    /** Client ID of the application. */
    client_id?: string | undefined;
    /** Name of the connection. */
    connection?: string | undefined;
    /** Email address of the user. */
    email?: string | undefined;
}

/** Represents a request to sign up a new user. */
export class SignupUserRequest extends UserMaintenanceRequestBase implements ISignupUserRequest {
    /** Initial password for this user. */
    password?: string | undefined;
    /** Username of this user. Only valid if the connection requires a username. */
    username?: string | undefined;
    /** Given name for this user. */
    given_name?: string | undefined;
    /** Family name for this user. */
    family_name?: string | undefined;
    /** Name of this user. */
    name?: string | undefined;
    /** Nickname of this user. */
    nickname?: string | undefined;
    /** URL to a picture of this user. */
    picture?: string | undefined;
    /** Metadata the user has read/write access to.  */
    user_metadata?: any | undefined;

    constructor(data?: ISignupUserRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.password = _data["password"];
            this.username = _data["username"];
            this.given_name = _data["given_name"];
            this.family_name = _data["family_name"];
            this.name = _data["name"];
            this.nickname = _data["nickname"];
            this.picture = _data["picture"];
            this.user_metadata = _data["user_metadata"];
        }
    }

    static override fromJS(data: any): SignupUserRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SignupUserRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["username"] = this.username;
        data["given_name"] = this.given_name;
        data["family_name"] = this.family_name;
        data["name"] = this.name;
        data["nickname"] = this.nickname;
        data["picture"] = this.picture;
        data["user_metadata"] = this.user_metadata;
        super.toJSON(data);
        return data;
    }
}

/** Represents a request to sign up a new user. */
export interface ISignupUserRequest extends IUserMaintenanceRequestBase {
    /** Initial password for this user. */
    password?: string | undefined;
    /** Username of this user. Only valid if the connection requires a username. */
    username?: string | undefined;
    /** Given name for this user. */
    given_name?: string | undefined;
    /** Family name for this user. */
    family_name?: string | undefined;
    /** Name of this user. */
    name?: string | undefined;
    /** Nickname of this user. */
    nickname?: string | undefined;
    /** URL to a picture of this user. */
    picture?: string | undefined;
    /** Metadata the user has read/write access to.  */
    user_metadata?: any | undefined;
}

/** PagedResult{TSource} */
export class PagedResultOfDisciplineResponseDto extends PagedResult implements IPagedResultOfDisciplineResponseDto {
    queryable!: DisciplineResponseDto[];

    constructor(data?: IPagedResultOfDisciplineResponseDto) {
        super(data);
        if (!data) {
            this.queryable = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(DisciplineResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PagedResultOfDisciplineResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfDisciplineResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** PagedResult{TSource} */
export interface IPagedResultOfDisciplineResponseDto extends IPagedResult {
    queryable: DisciplineResponseDto[];
}

/** PagedResult{TSource} */
export class PagedResultOfInstitutionResponseDto extends PagedResult implements IPagedResultOfInstitutionResponseDto {
    queryable!: InstitutionResponseDto[];

    constructor(data?: IPagedResultOfInstitutionResponseDto) {
        super(data);
        if (!data) {
            this.queryable = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(InstitutionResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PagedResultOfInstitutionResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfInstitutionResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** PagedResult{TSource} */
export interface IPagedResultOfInstitutionResponseDto extends IPagedResult {
    queryable: InstitutionResponseDto[];
}

export class InstitutionRequestDto implements IInstitutionRequestDto {
    id!: string;
    name!: string;
    state!: string;
    stadual!: boolean;
    privateInstitution!: boolean;

    constructor(data?: IInstitutionRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.state = _data["state"];
            this.stadual = _data["stadual"];
            this.privateInstitution = _data["privateInstitution"];
        }
    }

    static fromJS(data: any): InstitutionRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstitutionRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["state"] = this.state;
        data["stadual"] = this.stadual;
        data["privateInstitution"] = this.privateInstitution;
        return data;
    }
}

export interface IInstitutionRequestDto {
    id: string;
    name: string;
    state: string;
    stadual: boolean;
    privateInstitution: boolean;
}

export class InstitutionResponseDto extends InstitutionRequestDto implements IInstitutionResponseDto {
    questions!: QuestionResponseDto[];
    questionBanks!: QuestionBankResponseDto[];

    constructor(data?: IInstitutionResponseDto) {
        super(data);
        if (!data) {
            this.questions = [];
            this.questionBanks = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(QuestionResponseDto.fromJS(item));
            }
            if (Array.isArray(_data["questionBanks"])) {
                this.questionBanks = [] as any;
                for (let item of _data["questionBanks"])
                    this.questionBanks!.push(QuestionBankResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): InstitutionResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstitutionResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        if (Array.isArray(this.questionBanks)) {
            data["questionBanks"] = [];
            for (let item of this.questionBanks)
                data["questionBanks"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IInstitutionResponseDto extends IInstitutionRequestDto {
    questions: QuestionResponseDto[];
    questionBanks: QuestionBankResponseDto[];
}

export class QuestionBankRequestDto implements IQuestionBankRequestDto {
    id!: string;
    name!: string;
    institutionId?: string | undefined;

    constructor(data?: IQuestionBankRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.institutionId = _data["institutionId"];
        }
    }

    static fromJS(data: any): QuestionBankRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionBankRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["institutionId"] = this.institutionId;
        return data;
    }
}

export interface IQuestionBankRequestDto {
    id: string;
    name: string;
    institutionId?: string | undefined;
}

export class QuestionBankResponseDto extends QuestionBankRequestDto implements IQuestionBankResponseDto {
    institution?: InstitutionResponseDto | undefined;
    questions!: QuestionResponseDto[];
    questionsCount!: number;

    constructor(data?: IQuestionBankResponseDto) {
        super(data);
        if (!data) {
            this.questions = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.institution = _data["institution"] ? InstitutionResponseDto.fromJS(_data["institution"]) : <any>undefined;
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(QuestionResponseDto.fromJS(item));
            }
            this.questionsCount = _data["questionsCount"];
        }
    }

    static override fromJS(data: any): QuestionBankResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionBankResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["institution"] = this.institution ? this.institution.toJSON() : <any>undefined;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        data["questionsCount"] = this.questionsCount;
        super.toJSON(data);
        return data;
    }
}

export interface IQuestionBankResponseDto extends IQuestionBankRequestDto {
    institution?: InstitutionResponseDto | undefined;
    questions: QuestionResponseDto[];
    questionsCount: number;
}

/** PagedResult{TSource} */
export class PagedResultOfObservationResponseDto extends PagedResult implements IPagedResultOfObservationResponseDto {
    queryable!: ObservationResponseDto[];

    constructor(data?: IPagedResultOfObservationResponseDto) {
        super(data);
        if (!data) {
            this.queryable = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(ObservationResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PagedResultOfObservationResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfObservationResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** PagedResult{TSource} */
export interface IPagedResultOfObservationResponseDto extends IPagedResult {
    queryable: ObservationResponseDto[];
}

/** PagedResult{TSource} */
export class PagedResultOfObservationRequestResponseDto extends PagedResult implements IPagedResultOfObservationRequestResponseDto {
    queryable!: ObservationRequestResponseDto[];

    constructor(data?: IPagedResultOfObservationRequestResponseDto) {
        super(data);
        if (!data) {
            this.queryable = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(ObservationRequestResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PagedResultOfObservationRequestResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfObservationRequestResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** PagedResult{TSource} */
export interface IPagedResultOfObservationRequestResponseDto extends IPagedResult {
    queryable: ObservationRequestResponseDto[];
}

/** PagedResult{TSource} */
export class PagedResultOfQuestionBankResponseDto extends PagedResult implements IPagedResultOfQuestionBankResponseDto {
    queryable!: QuestionBankResponseDto[];

    constructor(data?: IPagedResultOfQuestionBankResponseDto) {
        super(data);
        if (!data) {
            this.queryable = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(QuestionBankResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PagedResultOfQuestionBankResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfQuestionBankResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** PagedResult{TSource} */
export interface IPagedResultOfQuestionBankResponseDto extends IPagedResult {
    queryable: QuestionBankResponseDto[];
}

/** PagedResult{TSource} */
export class PagedResultOfSelectListItem extends PagedResult implements IPagedResultOfSelectListItem {
    queryable!: SelectListItem[];

    constructor(data?: IPagedResultOfSelectListItem) {
        super(data);
        if (!data) {
            this.queryable = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(SelectListItem.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PagedResultOfSelectListItem {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfSelectListItem();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** PagedResult{TSource} */
export interface IPagedResultOfSelectListItem extends IPagedResult {
    queryable: SelectListItem[];
}

export class SelectListItem implements ISelectListItem {
    disabled!: boolean;
    group?: SelectListGroup | undefined;
    selected!: boolean;
    text?: string | undefined;
    value?: string | undefined;

    constructor(data?: ISelectListItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.disabled = _data["disabled"];
            this.group = _data["group"] ? SelectListGroup.fromJS(_data["group"]) : <any>undefined;
            this.selected = _data["selected"];
            this.text = _data["text"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SelectListItem {
        data = typeof data === 'object' ? data : {};
        let result = new SelectListItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["disabled"] = this.disabled;
        data["group"] = this.group ? this.group.toJSON() : <any>undefined;
        data["selected"] = this.selected;
        data["text"] = this.text;
        data["value"] = this.value;
        return data;
    }
}

export interface ISelectListItem {
    disabled: boolean;
    group?: SelectListGroup | undefined;
    selected: boolean;
    text?: string | undefined;
    value?: string | undefined;
}

export class SelectListGroup implements ISelectListGroup {
    disabled!: boolean;
    name?: string | undefined;

    constructor(data?: ISelectListGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.disabled = _data["disabled"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SelectListGroup {
        data = typeof data === 'object' ? data : {};
        let result = new SelectListGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["disabled"] = this.disabled;
        data["name"] = this.name;
        return data;
    }
}

export interface ISelectListGroup {
    disabled: boolean;
    name?: string | undefined;
}

/** PagedResult{TSource} */
export class PagedResultOfQuestionRequestDto extends PagedResult implements IPagedResultOfQuestionRequestDto {
    queryable!: QuestionRequestDto[];

    constructor(data?: IPagedResultOfQuestionRequestDto) {
        super(data);
        if (!data) {
            this.queryable = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(QuestionRequestDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PagedResultOfQuestionRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfQuestionRequestDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** PagedResult{TSource} */
export interface IPagedResultOfQuestionRequestDto extends IPagedResult {
    queryable: QuestionRequestDto[];
}

/** PagedResult{TSource} */
export class PagedResultOfQuestionResponseDto extends PagedResult implements IPagedResultOfQuestionResponseDto {
    queryable!: QuestionResponseDto[];

    constructor(data?: IPagedResultOfQuestionResponseDto) {
        super(data);
        if (!data) {
            this.queryable = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(QuestionResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PagedResultOfQuestionResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfQuestionResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** PagedResult{TSource} */
export interface IPagedResultOfQuestionResponseDto extends IPagedResult {
    queryable: QuestionResponseDto[];
}

/** PagedResult{TSource} */
export class PagedResultOfQuizAttemptConfigurationResponseDto extends PagedResult implements IPagedResultOfQuizAttemptConfigurationResponseDto {
    queryable!: QuizAttemptConfigurationResponseDto[];

    constructor(data?: IPagedResultOfQuizAttemptConfigurationResponseDto) {
        super(data);
        if (!data) {
            this.queryable = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(QuizAttemptConfigurationResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PagedResultOfQuizAttemptConfigurationResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfQuizAttemptConfigurationResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** PagedResult{TSource} */
export interface IPagedResultOfQuizAttemptConfigurationResponseDto extends IPagedResult {
    queryable: QuizAttemptConfigurationResponseDto[];
}

export class QuizAttemptConfigurationRequestDto implements IQuizAttemptConfigurationRequestDto {
    id?: string | undefined;
    name!: string;
    image?: string | undefined;
    user?: string | undefined;
    description?: string | undefined;
    boards?: string[] | undefined;
    years?: number[] | undefined;
    institutions?: string[] | undefined;
    disciplines?: string[] | undefined;
    random?: boolean | undefined;
    onlyNotAnswered?: boolean | undefined;
    onlyWrongs?: boolean | undefined;
    active!: boolean;
    showOnFront!: boolean;
    users?: string[] | undefined;
    usersCount!: number;
    userIds?: string | undefined;
    crews?: CrewRequestDto[] | undefined;
    crewsCount!: number;
    crewsIds?: string | undefined;
    questions?: QuestionRequestDto[] | undefined;
    questionsCount!: number;
    questionsIds?: string | undefined;
    data?: string | undefined;

    constructor(data?: IQuizAttemptConfigurationRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.image = _data["image"];
            this.user = _data["user"];
            this.description = _data["description"];
            if (Array.isArray(_data["boards"])) {
                this.boards = [] as any;
                for (let item of _data["boards"])
                    this.boards!.push(item);
            }
            if (Array.isArray(_data["years"])) {
                this.years = [] as any;
                for (let item of _data["years"])
                    this.years!.push(item);
            }
            if (Array.isArray(_data["institutions"])) {
                this.institutions = [] as any;
                for (let item of _data["institutions"])
                    this.institutions!.push(item);
            }
            if (Array.isArray(_data["disciplines"])) {
                this.disciplines = [] as any;
                for (let item of _data["disciplines"])
                    this.disciplines!.push(item);
            }
            this.random = _data["random"];
            this.onlyNotAnswered = _data["onlyNotAnswered"];
            this.onlyWrongs = _data["onlyWrongs"];
            this.active = _data["active"];
            this.showOnFront = _data["showOnFront"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(item);
            }
            this.usersCount = _data["usersCount"];
            this.userIds = _data["userIds"];
            if (Array.isArray(_data["crews"])) {
                this.crews = [] as any;
                for (let item of _data["crews"])
                    this.crews!.push(CrewRequestDto.fromJS(item));
            }
            this.crewsCount = _data["crewsCount"];
            this.crewsIds = _data["crewsIds"];
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(QuestionRequestDto.fromJS(item));
            }
            this.questionsCount = _data["questionsCount"];
            this.questionsIds = _data["questionsIds"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): QuizAttemptConfigurationRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuizAttemptConfigurationRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["image"] = this.image;
        data["user"] = this.user;
        data["description"] = this.description;
        if (Array.isArray(this.boards)) {
            data["boards"] = [];
            for (let item of this.boards)
                data["boards"].push(item);
        }
        if (Array.isArray(this.years)) {
            data["years"] = [];
            for (let item of this.years)
                data["years"].push(item);
        }
        if (Array.isArray(this.institutions)) {
            data["institutions"] = [];
            for (let item of this.institutions)
                data["institutions"].push(item);
        }
        if (Array.isArray(this.disciplines)) {
            data["disciplines"] = [];
            for (let item of this.disciplines)
                data["disciplines"].push(item);
        }
        data["random"] = this.random;
        data["onlyNotAnswered"] = this.onlyNotAnswered;
        data["onlyWrongs"] = this.onlyWrongs;
        data["active"] = this.active;
        data["showOnFront"] = this.showOnFront;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item);
        }
        data["usersCount"] = this.usersCount;
        data["userIds"] = this.userIds;
        if (Array.isArray(this.crews)) {
            data["crews"] = [];
            for (let item of this.crews)
                data["crews"].push(item.toJSON());
        }
        data["crewsCount"] = this.crewsCount;
        data["crewsIds"] = this.crewsIds;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        data["questionsCount"] = this.questionsCount;
        data["questionsIds"] = this.questionsIds;
        data["data"] = this.data;
        return data;
    }
}

export interface IQuizAttemptConfigurationRequestDto {
    id?: string | undefined;
    name: string;
    image?: string | undefined;
    user?: string | undefined;
    description?: string | undefined;
    boards?: string[] | undefined;
    years?: number[] | undefined;
    institutions?: string[] | undefined;
    disciplines?: string[] | undefined;
    random?: boolean | undefined;
    onlyNotAnswered?: boolean | undefined;
    onlyWrongs?: boolean | undefined;
    active: boolean;
    showOnFront: boolean;
    users?: string[] | undefined;
    usersCount: number;
    userIds?: string | undefined;
    crews?: CrewRequestDto[] | undefined;
    crewsCount: number;
    crewsIds?: string | undefined;
    questions?: QuestionRequestDto[] | undefined;
    questionsCount: number;
    questionsIds?: string | undefined;
    data?: string | undefined;
}

export class QuizAttemptConfigurationResponseDto extends QuizAttemptConfigurationRequestDto implements IQuizAttemptConfigurationResponseDto {
    institution?: InstitutionResponseDto | undefined;
    disciplines!: DisciplineResponseDto[];

    constructor(data?: IQuizAttemptConfigurationResponseDto) {
        super(data);
        if (!data) {
            this.disciplines = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.institution = _data["institution"] ? InstitutionResponseDto.fromJS(_data["institution"]) : <any>undefined;
            if (Array.isArray(_data["disciplines"])) {
                this.disciplines = [] as any;
                for (let item of _data["disciplines"])
                    this.disciplines!.push(DisciplineResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): QuizAttemptConfigurationResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuizAttemptConfigurationResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["institution"] = this.institution ? this.institution.toJSON() : <any>undefined;
        if (Array.isArray(this.disciplines)) {
            data["disciplines"] = [];
            for (let item of this.disciplines)
                data["disciplines"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IQuizAttemptConfigurationResponseDto extends IQuizAttemptConfigurationRequestDto {
    institution?: InstitutionResponseDto | undefined;
    disciplines: DisciplineResponseDto[];
}

export class CrewRequestDto implements ICrewRequestDto {
    id!: string;
    name!: string;
    user!: string;
    users!: string[];
    description!: string;
    data!: string;

    constructor(data?: ICrewRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.users = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.user = _data["user"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(item);
            }
            this.description = _data["description"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): CrewRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CrewRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["user"] = this.user;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item);
        }
        data["description"] = this.description;
        data["data"] = this.data;
        return data;
    }
}

export interface ICrewRequestDto {
    id: string;
    name: string;
    user: string;
    users: string[];
    description: string;
    data: string;
}

/** Specifies pagination info to use when requesting paged results. */
export class PaginationInfo implements IPaginationInfo {
    /** Return results with a total result count (true) or with no totals (false, default). */
    includeTotals!: boolean;
    /** Number of results per page. */
    perPage!: number;
    /** Page index of the results to return. First page is 0. */
    pageNo!: number;

    constructor(data?: IPaginationInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.includeTotals = _data["includeTotals"];
            this.perPage = _data["perPage"];
            this.pageNo = _data["pageNo"];
        }
    }

    static fromJS(data: any): PaginationInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PaginationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["includeTotals"] = this.includeTotals;
        data["perPage"] = this.perPage;
        data["pageNo"] = this.pageNo;
        return data;
    }
}

/** Specifies pagination info to use when requesting paged results. */
export interface IPaginationInfo {
    /** Return results with a total result count (true) or with no totals (false, default). */
    includeTotals: boolean;
    /** Number of results per page. */
    perPage: number;
    /** Page index of the results to return. First page is 0. */
    pageNo: number;
}

/** Contains details of permissions that should be assigned to a role. */
export class AssignPermissionsRequest implements IAssignPermissionsRequest {
    /** User IDs to assign to the role. */
    permissions?: PermissionIdentity[] | undefined;

    constructor(data?: IAssignPermissionsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionIdentity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AssignPermissionsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AssignPermissionsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }
}

/** Contains details of permissions that should be assigned to a role. */
export interface IAssignPermissionsRequest {
    /** User IDs to assign to the role. */
    permissions?: PermissionIdentity[] | undefined;
}

/** Represents the properties of a permission that give it its unique identity. */
export class PermissionIdentity implements IPermissionIdentity {
    /** The resource server that the permission is attached to. */
    resource_server_identifier?: string | undefined;
    /** The name of the permission. */
    permission_name?: string | undefined;

    constructor(data?: IPermissionIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resource_server_identifier = _data["resource_server_identifier"];
            this.permission_name = _data["permission_name"];
        }
    }

    static fromJS(data: any): PermissionIdentity {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionIdentity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resource_server_identifier"] = this.resource_server_identifier;
        data["permission_name"] = this.permission_name;
        return data;
    }
}

/** Represents the properties of a permission that give it its unique identity. */
export interface IPermissionIdentity {
    /** The resource server that the permission is attached to. */
    resource_server_identifier?: string | undefined;
    /** The name of the permission. */
    permission_name?: string | undefined;
}

/** Contains details of roles that should be assigned to a user. */
export class AssignRolesRequest implements IAssignRolesRequest {
    /** Role IDs to assign to the user. */
    roles?: string[] | undefined;

    constructor(data?: IAssignRolesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): AssignRolesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AssignRolesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

/** Contains details of roles that should be assigned to a user. */
export interface IAssignRolesRequest {
    /** Role IDs to assign to the user. */
    roles?: string[] | undefined;
}

export class Queryable implements IQueryable {

    [key: string]: any;

    constructor(data?: IQueryable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Queryable {
        data = typeof data === 'object' ? data : {};
        let result = new Queryable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IQueryable {

    [key: string]: any;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}