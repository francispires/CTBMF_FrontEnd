//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.3.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class AnswerClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    ranking(signal?: AbortSignal): Promise<RankingAnswersResponseDto[]> {
        let url_ = this.baseUrl + "/api/answers/ranking";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRanking(_response);
        });
    }

    protected processRanking(response: Response): Promise<RankingAnswersResponseDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RankingAnswersResponseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RankingAnswersResponseDto[]>(null as any);
    }

    my(signal?: AbortSignal): Promise<RankingAnswersResponseDto[]> {
        let url_ = this.baseUrl + "/api/answers/my";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMy(_response);
        });
    }

    protected processMy(response: Response): Promise<RankingAnswersResponseDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RankingAnswersResponseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RankingAnswersResponseDto[]>(null as any);
    }

    /**
     * Get all records of type T
     * @param currentPage (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @param filter (optional) 
     * @return A PagedResult T with queryable holding the items
     */
    getAll(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfAnswerResponseDto> {
        let url_ = this.baseUrl + "/api/answers?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<PagedResultOfAnswerResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfAnswerResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfAnswerResponseDto>(null as any);
    }

    /**
     * Create a record of type T
     * @param body The RequestDto to create object
     * @return The created item T
     */
    create(body: AnswerRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/answers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Get a record of type T by id
     * @param id The id of the item
     * @return A item T
     */
    get(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/answers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Delete a record of type T by id
     * @param id The id of the item to be removed
     * @return True on success, false otherwise
     */
    delete(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/answers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Update a record of type T by id
     * @param id The id of the item to be updated
     * @param body The updated body to be saved
     * @return True on success, false otherwise
     */
    update(id: string, body: AnswerRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/answers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload(contentType: string | undefined, contentDisposition: string | undefined, headers: Headers[] | undefined, length: number | undefined, name: string | undefined, fileNameFormData: string | undefined, fileNameQuery: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/answers/upload?";
        if (fileNameQuery === null)
            throw new Error("The parameter 'fileNameQuery' cannot be null.");
        else if (fileNameQuery !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileNameQuery) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType === null || contentType === undefined)
            throw new Error("The parameter 'contentType' cannot be null.");
        else
            content_.append("ContentType", contentType.toString());
        if (contentDisposition === null || contentDisposition === undefined)
            throw new Error("The parameter 'contentDisposition' cannot be null.");
        else
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers === null || headers === undefined)
            throw new Error("The parameter 'headers' cannot be null.");
        else
            headers.forEach(item_ => content_.append("Headers", item_.toString()));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (fileNameFormData === null || fileNameFormData === undefined)
            throw new Error("The parameter 'fileNameFormData' cannot be null.");
        else
            content_.append("FileName", fileNameFormData.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload64(file: string | undefined, fileName: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/answers/upload64?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload64(_response);
        });
    }

    protected processUpload64(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

export class AuthClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    signIn(user: UserCreateRequest, signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/auth/signin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSignIn(_response);
        });
    }

    protected processSignIn(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }

    signUp(user: SignupUserRequest, signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/auth/signup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSignUp(_response);
        });
    }

    protected processSignUp(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }

    create(user: UserCreateRequest, signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/auth/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }

    remove(id: string | undefined, signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/auth/remove?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemove(_response);
        });
    }

    protected processRemove(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }

    getPermissions(id: string, paginationInfo: PaginationInfo, signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/auth/permissions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(paginationInfo);

        let options_: RequestInit = {
            body: content_,
            method: "GET",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPermissions(_response);
        });
    }

    protected processGetPermissions(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }

    addPermission(id: string, permissionsRequest: AssignPermissionsRequest, signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/auth/permissions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(permissionsRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddPermission(_response);
        });
    }

    protected processAddPermission(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }

    getRoles(id: string, paginationInfo: PaginationInfo, signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/auth/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(paginationInfo);

        let options_: RequestInit = {
            body: content_,
            method: "GET",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRoles(_response);
        });
    }

    protected processGetRoles(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }

    addRole(id: string, rolesRequest: AssignRolesRequest, signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/auth/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(rolesRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddRole(_response);
        });
    }

    protected processAddRole(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }

    get(id: string, signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/auth/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }

    get2(currentPage: number | undefined, pageSize: number | undefined, filter: string | null | undefined, sort: string | null | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/auth/all?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "currentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet2(_response);
        });
    }

    protected processGet2(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

export class ConfigClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    getAll(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfConfigResponseDto> {
        let url_ = this.baseUrl + "/api/configs?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<PagedResultOfConfigResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfConfigResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfConfigResponseDto>(null as any);
    }

    /**
     * Create a record of type T
     * @param body The RequestDto to create object
     * @return The created item T
     */
    create(body: ConfigRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/configs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Get a record of type T by id
     * @param id The id of the item
     * @return A item T
     */
    get(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/configs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Delete a record of type T by id
     * @param id The id of the item to be removed
     * @return True on success, false otherwise
     */
    delete(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/configs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Update a record of type T by id
     * @param id The id of the item to be updated
     * @param body The updated body to be saved
     * @return True on success, false otherwise
     */
    update(id: string, body: ConfigRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/configs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload(contentType: string | undefined, contentDisposition: string | undefined, headers: Headers2[] | undefined, length: number | undefined, name: string | undefined, fileNameFormData: string | undefined, fileNameQuery: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/configs/upload?";
        if (fileNameQuery === null)
            throw new Error("The parameter 'fileNameQuery' cannot be null.");
        else if (fileNameQuery !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileNameQuery) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType === null || contentType === undefined)
            throw new Error("The parameter 'contentType' cannot be null.");
        else
            content_.append("ContentType", contentType.toString());
        if (contentDisposition === null || contentDisposition === undefined)
            throw new Error("The parameter 'contentDisposition' cannot be null.");
        else
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers === null || headers === undefined)
            throw new Error("The parameter 'headers' cannot be null.");
        else
            headers.forEach(item_ => content_.append("Headers", item_.toString()));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (fileNameFormData === null || fileNameFormData === undefined)
            throw new Error("The parameter 'fileNameFormData' cannot be null.");
        else
            content_.append("FileName", fileNameFormData.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload64(file: string | undefined, fileName: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/configs/upload64?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload64(_response);
        });
    }

    protected processUpload64(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

export class CrewClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    /**
     * Get all records of type T
     * @param currentPage (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @param filter (optional) 
     * @return A PagedResult T with queryable holding the items
     */
    getAll(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfCrewResponseDto> {
        let url_ = this.baseUrl + "/api/crews?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<PagedResultOfCrewResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfCrewResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfCrewResponseDto>(null as any);
    }

    /**
     * Create a record of type T
     * @param body The RequestDto to create object
     * @return The created item T
     */
    create(body: CrewRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/crews";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Get a record of type T by id
     * @param id The id of the item
     * @return A item T
     */
    get(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/crews/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Delete a record of type T by id
     * @param id The id of the item to be removed
     * @return True on success, false otherwise
     */
    delete(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/crews/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Update a record of type T by id
     * @param id The id of the item to be updated
     * @param body The updated body to be saved
     * @return True on success, false otherwise
     */
    update(id: string, body: CrewRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/crews/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload(contentType: string | undefined, contentDisposition: string | undefined, headers: Headers3[] | undefined, length: number | undefined, name: string | undefined, fileNameFormData: string | undefined, fileNameQuery: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/crews/upload?";
        if (fileNameQuery === null)
            throw new Error("The parameter 'fileNameQuery' cannot be null.");
        else if (fileNameQuery !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileNameQuery) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType === null || contentType === undefined)
            throw new Error("The parameter 'contentType' cannot be null.");
        else
            content_.append("ContentType", contentType.toString());
        if (contentDisposition === null || contentDisposition === undefined)
            throw new Error("The parameter 'contentDisposition' cannot be null.");
        else
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers === null || headers === undefined)
            throw new Error("The parameter 'headers' cannot be null.");
        else
            headers.forEach(item_ => content_.append("Headers", item_.toString()));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (fileNameFormData === null || fileNameFormData === undefined)
            throw new Error("The parameter 'fileNameFormData' cannot be null.");
        else
            content_.append("FileName", fileNameFormData.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload64(file: string | undefined, fileName: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/crews/upload64?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload64(_response);
        });
    }

    protected processUpload64(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

export class DisciplinesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    /**
     * Get all records of type T
     * @param currentPage (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @param filter (optional) 
     * @return A PagedResult T with queryable holding the items
     */
    getAll(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfDisciplineResponseDto> {
        let url_ = this.baseUrl + "/api/disciplines?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<PagedResultOfDisciplineResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfDisciplineResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfDisciplineResponseDto>(null as any);
    }

    /**
     * Create a record of type T
     * @param body The RequestDto to create object
     * @return The created item T
     */
    create(body: DisciplineRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/disciplines";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Get a record of type T by id
     * @param id The id of the item
     * @return A item T
     */
    get(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/disciplines/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Delete a record of type T by id
     * @param id The id of the item to be removed
     * @return True on success, false otherwise
     */
    delete(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/disciplines/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Update a record of type T by id
     * @param id The id of the item to be updated
     * @param body The updated body to be saved
     * @return True on success, false otherwise
     */
    update(id: string, body: DisciplineRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/disciplines/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload(contentType: string | undefined, contentDisposition: string | undefined, headers: Headers4[] | undefined, length: number | undefined, name: string | undefined, fileNameFormData: string | undefined, fileNameQuery: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/disciplines/upload?";
        if (fileNameQuery === null)
            throw new Error("The parameter 'fileNameQuery' cannot be null.");
        else if (fileNameQuery !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileNameQuery) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType === null || contentType === undefined)
            throw new Error("The parameter 'contentType' cannot be null.");
        else
            content_.append("ContentType", contentType.toString());
        if (contentDisposition === null || contentDisposition === undefined)
            throw new Error("The parameter 'contentDisposition' cannot be null.");
        else
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers === null || headers === undefined)
            throw new Error("The parameter 'headers' cannot be null.");
        else
            headers.forEach(item_ => content_.append("Headers", item_.toString()));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (fileNameFormData === null || fileNameFormData === undefined)
            throw new Error("The parameter 'fileNameFormData' cannot be null.");
        else
            content_.append("FileName", fileNameFormData.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload64(file: string | undefined, fileName: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/disciplines/upload64?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload64(_response);
        });
    }

    protected processUpload64(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

export class EnrollmentClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    /**
     * Get all records of type T
     * @param currentPage (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @param filter (optional) 
     * @return A PagedResult T with queryable holding the items
     */
    getAll(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfEnrollmentResponseDto> {
        let url_ = this.baseUrl + "/api/enrollments?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<PagedResultOfEnrollmentResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfEnrollmentResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfEnrollmentResponseDto>(null as any);
    }

    /**
     * Create a record of type T
     * @param body The RequestDto to create object
     * @return The created item T
     */
    create(body: EnrollmentRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/enrollments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Get a record of type T by id
     * @param id The id of the item
     * @return A item T
     */
    get(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/enrollments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Delete a record of type T by id
     * @param id The id of the item to be removed
     * @return True on success, false otherwise
     */
    delete(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/enrollments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Update a record of type T by id
     * @param id The id of the item to be updated
     * @param body The updated body to be saved
     * @return True on success, false otherwise
     */
    update(id: string, body: EnrollmentRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/enrollments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload(contentType: string | undefined, contentDisposition: string | undefined, headers: Headers5[] | undefined, length: number | undefined, name: string | undefined, fileNameFormData: string | undefined, fileNameQuery: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/enrollments/upload?";
        if (fileNameQuery === null)
            throw new Error("The parameter 'fileNameQuery' cannot be null.");
        else if (fileNameQuery !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileNameQuery) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType === null || contentType === undefined)
            throw new Error("The parameter 'contentType' cannot be null.");
        else
            content_.append("ContentType", contentType.toString());
        if (contentDisposition === null || contentDisposition === undefined)
            throw new Error("The parameter 'contentDisposition' cannot be null.");
        else
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers === null || headers === undefined)
            throw new Error("The parameter 'headers' cannot be null.");
        else
            headers.forEach(item_ => content_.append("Headers", item_.toString()));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (fileNameFormData === null || fileNameFormData === undefined)
            throw new Error("The parameter 'fileNameFormData' cannot be null.");
        else
            content_.append("FileName", fileNameFormData.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload64(file: string | undefined, fileName: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/enrollments/upload64?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload64(_response);
        });
    }

    protected processUpload64(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

export class ErrorClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    handleErrorDevelopmentGET(signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/error";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHandleErrorDevelopmentGET(_response);
        });
    }

    protected processHandleErrorDevelopmentGET(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    handleErrorDevelopmentPOST(signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/error";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHandleErrorDevelopmentPOST(_response);
        });
    }

    protected processHandleErrorDevelopmentPOST(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

export class InstitutionsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    /**
     * Get all records of type T
     * @param currentPage (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @param filter (optional) 
     * @return A PagedResult T with queryable holding the items
     */
    getAll(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfInstitutionResponseDto> {
        let url_ = this.baseUrl + "/api/institutions?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<PagedResultOfInstitutionResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfInstitutionResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfInstitutionResponseDto>(null as any);
    }

    /**
     * Create a record of type T
     * @param body The RequestDto to create object
     * @return The created item T
     */
    create(body: InstitutionRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/institutions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Get a record of type T by id
     * @param id The id of the item
     * @return A item T
     */
    get(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/institutions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Delete a record of type T by id
     * @param id The id of the item to be removed
     * @return True on success, false otherwise
     */
    delete(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/institutions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Update a record of type T by id
     * @param id The id of the item to be updated
     * @param body The updated body to be saved
     * @return True on success, false otherwise
     */
    update(id: string, body: InstitutionRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/institutions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload(contentType: string | undefined, contentDisposition: string | undefined, headers: Headers6[] | undefined, length: number | undefined, name: string | undefined, fileNameFormData: string | undefined, fileNameQuery: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/institutions/upload?";
        if (fileNameQuery === null)
            throw new Error("The parameter 'fileNameQuery' cannot be null.");
        else if (fileNameQuery !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileNameQuery) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType === null || contentType === undefined)
            throw new Error("The parameter 'contentType' cannot be null.");
        else
            content_.append("ContentType", contentType.toString());
        if (contentDisposition === null || contentDisposition === undefined)
            throw new Error("The parameter 'contentDisposition' cannot be null.");
        else
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers === null || headers === undefined)
            throw new Error("The parameter 'headers' cannot be null.");
        else
            headers.forEach(item_ => content_.append("Headers", item_.toString()));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (fileNameFormData === null || fileNameFormData === undefined)
            throw new Error("The parameter 'fileNameFormData' cannot be null.");
        else
            content_.append("FileName", fileNameFormData.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload64(file: string | undefined, fileName: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/institutions/upload64?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload64(_response);
        });
    }

    protected processUpload64(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

export class ObservationsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    create(body: ObservationRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/observations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Get all records of type T
     * @param currentPage (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @param filter (optional) 
     * @return A PagedResult T with queryable holding the items
     */
    getAll(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfObservationResponseDto> {
        let url_ = this.baseUrl + "/api/observations?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<PagedResultOfObservationResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfObservationResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfObservationResponseDto>(null as any);
    }

    /**
     * Get a record of type T by id
     * @param id The id of the item
     * @return A item T
     */
    get(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/observations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Delete a record of type T by id
     * @param id The id of the item to be removed
     * @return True on success, false otherwise
     */
    delete(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/observations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Update a record of type T by id
     * @param id The id of the item to be updated
     * @param body The updated body to be saved
     * @return True on success, false otherwise
     */
    update(id: string, body: ObservationRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/observations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload(contentType: string | undefined, contentDisposition: string | undefined, headers: Headers7[] | undefined, length: number | undefined, name: string | undefined, fileNameFormData: string | undefined, fileNameQuery: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/observations/upload?";
        if (fileNameQuery === null)
            throw new Error("The parameter 'fileNameQuery' cannot be null.");
        else if (fileNameQuery !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileNameQuery) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType === null || contentType === undefined)
            throw new Error("The parameter 'contentType' cannot be null.");
        else
            content_.append("ContentType", contentType.toString());
        if (contentDisposition === null || contentDisposition === undefined)
            throw new Error("The parameter 'contentDisposition' cannot be null.");
        else
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers === null || headers === undefined)
            throw new Error("The parameter 'headers' cannot be null.");
        else
            headers.forEach(item_ => content_.append("Headers", item_.toString()));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (fileNameFormData === null || fileNameFormData === undefined)
            throw new Error("The parameter 'fileNameFormData' cannot be null.");
        else
            content_.append("FileName", fileNameFormData.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload64(file: string | undefined, fileName: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/observations/upload64?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload64(_response);
        });
    }

    protected processUpload64(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

export class ObservationsRequestClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    create(body: ObservationRequestRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/observations_request";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Get all records of type T
     * @param currentPage (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @param filter (optional) 
     * @return A PagedResult T with queryable holding the items
     */
    getAll(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfObservationRequestResponseDto> {
        let url_ = this.baseUrl + "/api/observations_request?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<PagedResultOfObservationRequestResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfObservationRequestResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfObservationRequestResponseDto>(null as any);
    }

    getByQuestionId(id: string, currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfObservationRequestResponseDto> {
        let url_ = this.baseUrl + "/api/observations_request/question/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetByQuestionId(_response);
        });
    }

    protected processGetByQuestionId(response: Response): Promise<PagedResultOfObservationRequestResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfObservationRequestResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfObservationRequestResponseDto>(null as any);
    }

    answer(id: string, request: ObservationRequestDto, signal?: AbortSignal): Promise<PagedResultOfObservationRequestResponseDto> {
        let url_ = this.baseUrl + "/api/observations_request/answer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAnswer(_response);
        });
    }

    protected processAnswer(response: Response): Promise<PagedResultOfObservationRequestResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfObservationRequestResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfObservationRequestResponseDto>(null as any);
    }

    /**
     * Get a record of type T by id
     * @param id The id of the item
     * @return A item T
     */
    get(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/observations_request/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Delete a record of type T by id
     * @param id The id of the item to be removed
     * @return True on success, false otherwise
     */
    delete(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/observations_request/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Update a record of type T by id
     * @param id The id of the item to be updated
     * @param body The updated body to be saved
     * @return True on success, false otherwise
     */
    update(id: string, body: ObservationRequestRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/observations_request/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload(contentType: string | undefined, contentDisposition: string | undefined, headers: Headers8[] | undefined, length: number | undefined, name: string | undefined, fileNameFormData: string | undefined, fileNameQuery: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/observations_request/upload?";
        if (fileNameQuery === null)
            throw new Error("The parameter 'fileNameQuery' cannot be null.");
        else if (fileNameQuery !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileNameQuery) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType === null || contentType === undefined)
            throw new Error("The parameter 'contentType' cannot be null.");
        else
            content_.append("ContentType", contentType.toString());
        if (contentDisposition === null || contentDisposition === undefined)
            throw new Error("The parameter 'contentDisposition' cannot be null.");
        else
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers === null || headers === undefined)
            throw new Error("The parameter 'headers' cannot be null.");
        else
            headers.forEach(item_ => content_.append("Headers", item_.toString()));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (fileNameFormData === null || fileNameFormData === undefined)
            throw new Error("The parameter 'fileNameFormData' cannot be null.");
        else
            content_.append("FileName", fileNameFormData.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload64(file: string | undefined, fileName: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/observations_request/upload64?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload64(_response);
        });
    }

    protected processUpload64(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

export class MessagesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    getPublicMessage(signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/messages/public";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPublicMessage(_response);
        });
    }

    protected processGetPublicMessage(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }

    getProtectedMessage(signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/messages/protected";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProtectedMessage(_response);
        });
    }

    protected processGetProtectedMessage(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }

    getAdminMessage(signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/messages/admin";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAdminMessage(_response);
        });
    }

    protected processGetAdminMessage(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }
}

export class QuestionBankClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    /**
     * Get all records of type T
     * @param currentPage (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @param filter (optional) 
     * @return A PagedResult T with queryable holding the items
     */
    getAll(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfQuestionBankResponseDto> {
        let url_ = this.baseUrl + "/api/question_banks?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<PagedResultOfQuestionBankResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfQuestionBankResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfQuestionBankResponseDto>(null as any);
    }

    /**
     * Create a record of type T
     * @param body The RequestDto to create object
     * @return The created item T
     */
    create(body: QuestionBankRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/question_banks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Get a record of type T by id
     * @param id The id of the item
     * @return A item T
     */
    get(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/question_banks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Delete a record of type T by id
     * @param id The id of the item to be removed
     * @return True on success, false otherwise
     */
    delete(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/question_banks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Update a record of type T by id
     * @param id The id of the item to be updated
     * @param body The updated body to be saved
     * @return True on success, false otherwise
     */
    update(id: string, body: QuestionBankRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/question_banks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload(contentType: string | undefined, contentDisposition: string | undefined, headers: Headers9[] | undefined, length: number | undefined, name: string | undefined, fileNameFormData: string | undefined, fileNameQuery: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/question_banks/upload?";
        if (fileNameQuery === null)
            throw new Error("The parameter 'fileNameQuery' cannot be null.");
        else if (fileNameQuery !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileNameQuery) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType === null || contentType === undefined)
            throw new Error("The parameter 'contentType' cannot be null.");
        else
            content_.append("ContentType", contentType.toString());
        if (contentDisposition === null || contentDisposition === undefined)
            throw new Error("The parameter 'contentDisposition' cannot be null.");
        else
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers === null || headers === undefined)
            throw new Error("The parameter 'headers' cannot be null.");
        else
            headers.forEach(item_ => content_.append("Headers", item_.toString()));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (fileNameFormData === null || fileNameFormData === undefined)
            throw new Error("The parameter 'fileNameFormData' cannot be null.");
        else
            content_.append("FileName", fileNameFormData.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload64(file: string | undefined, fileName: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/question_banks/upload64?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload64(_response);
        });
    }

    protected processUpload64(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

export class QuestionClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    answer(body: AnswerRequestDto, signal?: AbortSignal): Promise<AnswerResponseDto> {
        let url_ = this.baseUrl + "/api/questions/answer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAnswer(_response);
        });
    }

    protected processAnswer(response: Response): Promise<AnswerResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AnswerResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AnswerResponseDto>(null as any);
    }

    create(body: QuestionRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/questions/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    update(id: string, body: QuestionRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/questions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Get a record of type T by id
     * @param id The id of the item
     * @return A item T
     */
    get(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/questions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Delete a record of type T by id
     * @param id The id of the item to be removed
     * @return True on success, false otherwise
     */
    delete(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/questions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    getAll(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfQuestionResponseDto> {
        let url_ = this.baseUrl + "/api/questions?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<PagedResultOfQuestionResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfQuestionResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfQuestionResponseDto>(null as any);
    }

    filter(onlyWrongs: boolean | null | undefined, random: boolean | null | undefined, onlyNotAnswereds: boolean | null | undefined, onlyAnswereds: boolean | null | undefined, onlyCorrects: boolean | null | undefined, institutionIds: string[] | null | undefined, boards: string[] | null | undefined, years: number[] | null | undefined, disciplines: string[] | null | undefined, subDisciplines: string[] | null | undefined, greatherThan: number | null | undefined, lessThan: number | null | undefined, quantity: number | null | undefined, questionNumber: number | null | undefined, attemptId: string | null | undefined, attemptConfigId: string | null | undefined, getAll: boolean | undefined, signal?: AbortSignal): Promise<PagedResultOfQuestionRequestDto> {
        let url_ = this.baseUrl + "/api/questions/filter?";
        if (onlyWrongs !== undefined && onlyWrongs !== null)
            url_ += "OnlyWrongs=" + encodeURIComponent("" + onlyWrongs) + "&";
        if (random !== undefined && random !== null)
            url_ += "Random=" + encodeURIComponent("" + random) + "&";
        if (onlyNotAnswereds !== undefined && onlyNotAnswereds !== null)
            url_ += "OnlyNotAnswereds=" + encodeURIComponent("" + onlyNotAnswereds) + "&";
        if (onlyAnswereds !== undefined && onlyAnswereds !== null)
            url_ += "OnlyAnswereds=" + encodeURIComponent("" + onlyAnswereds) + "&";
        if (onlyCorrects !== undefined && onlyCorrects !== null)
            url_ += "OnlyCorrects=" + encodeURIComponent("" + onlyCorrects) + "&";
        if (institutionIds !== undefined && institutionIds !== null)
            institutionIds && institutionIds.forEach(item => { url_ += "InstitutionIds=" + encodeURIComponent("" + item) + "&"; });
        if (boards !== undefined && boards !== null)
            boards && boards.forEach(item => { url_ += "Boards=" + encodeURIComponent("" + item) + "&"; });
        if (years !== undefined && years !== null)
            years && years.forEach(item => { url_ += "Years=" + encodeURIComponent("" + item) + "&"; });
        if (disciplines !== undefined && disciplines !== null)
            disciplines && disciplines.forEach(item => { url_ += "Disciplines=" + encodeURIComponent("" + item) + "&"; });
        if (subDisciplines !== undefined && subDisciplines !== null)
            subDisciplines && subDisciplines.forEach(item => { url_ += "SubDisciplines=" + encodeURIComponent("" + item) + "&"; });
        if (greatherThan !== undefined && greatherThan !== null)
            url_ += "GreatherThan=" + encodeURIComponent("" + greatherThan) + "&";
        if (lessThan !== undefined && lessThan !== null)
            url_ += "LessThan=" + encodeURIComponent("" + lessThan) + "&";
        if (quantity !== undefined && quantity !== null)
            url_ += "Quantity=" + encodeURIComponent("" + quantity) + "&";
        if (questionNumber !== undefined && questionNumber !== null)
            url_ += "QuestionNumber=" + encodeURIComponent("" + questionNumber) + "&";
        if (attemptId !== undefined && attemptId !== null)
            url_ += "AttemptId=" + encodeURIComponent("" + attemptId) + "&";
        if (attemptConfigId !== undefined && attemptConfigId !== null)
            url_ += "AttemptConfigId=" + encodeURIComponent("" + attemptConfigId) + "&";
        if (getAll === null)
            throw new Error("The parameter 'getAll' cannot be null.");
        else if (getAll !== undefined)
            url_ += "GetAll=" + encodeURIComponent("" + getAll) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFilter(_response);
        });
    }

    protected processFilter(response: Response): Promise<PagedResultOfQuestionRequestDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfQuestionRequestDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfQuestionRequestDto>(null as any);
    }

    years(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfSelectListItem> {
        let url_ = this.baseUrl + "/api/questions/years?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processYears(_response);
        });
    }

    protected processYears(response: Response): Promise<PagedResultOfSelectListItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfSelectListItem.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfSelectListItem>(null as any);
    }

    boards(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfSelectListItem> {
        let url_ = this.baseUrl + "/api/questions/boards?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBoards(_response);
        });
    }

    protected processBoards(response: Response): Promise<PagedResultOfSelectListItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfSelectListItem.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfSelectListItem>(null as any);
    }

    numbers(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfSelectListItem> {
        let url_ = this.baseUrl + "/api/questions/numbers?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNumbers(_response);
        });
    }

    protected processNumbers(response: Response): Promise<PagedResultOfSelectListItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfSelectListItem.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfSelectListItem>(null as any);
    }

    upload(contentType: string | undefined, contentDisposition: string | undefined, headers: Headers10[] | undefined, length: number | undefined, name: string | undefined, fileNameFormData: string | undefined, fileNameQuery: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/questions/upload?";
        if (fileNameQuery === null)
            throw new Error("The parameter 'fileNameQuery' cannot be null.");
        else if (fileNameQuery !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileNameQuery) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType === null || contentType === undefined)
            throw new Error("The parameter 'contentType' cannot be null.");
        else
            content_.append("ContentType", contentType.toString());
        if (contentDisposition === null || contentDisposition === undefined)
            throw new Error("The parameter 'contentDisposition' cannot be null.");
        else
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers === null || headers === undefined)
            throw new Error("The parameter 'headers' cannot be null.");
        else
            headers.forEach(item_ => content_.append("Headers", item_.toString()));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (fileNameFormData === null || fileNameFormData === undefined)
            throw new Error("The parameter 'fileNameFormData' cannot be null.");
        else
            content_.append("FileName", fileNameFormData.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload64(file: string | undefined, fileName: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/questions/upload64?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload64(_response);
        });
    }

    protected processUpload64(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

export class QuizAttemptClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    get(attemptConfigurationId: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/quiz_attempts/{attemptConfigurationId}";
        if (attemptConfigurationId === undefined || attemptConfigurationId === null)
            throw new Error("The parameter 'attemptConfigurationId' must be defined.");
        url_ = url_.replace("{attemptConfigurationId}", encodeURIComponent("" + attemptConfigurationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Get all records of type T
     * @param currentPage (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @param filter (optional) 
     * @return A PagedResult T with queryable holding the items
     */
    getAll(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfQuizAttemptResponseDto> {
        let url_ = this.baseUrl + "/api/quiz_attempts?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<PagedResultOfQuizAttemptResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfQuizAttemptResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfQuizAttemptResponseDto>(null as any);
    }

    /**
     * Create a record of type T
     * @param body The RequestDto to create object
     * @return The created item T
     */
    create(body: QuizAttemptRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/quiz_attempts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Delete a record of type T by id
     * @param id The id of the item to be removed
     * @return True on success, false otherwise
     */
    delete(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/quiz_attempts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Update a record of type T by id
     * @param id The id of the item to be updated
     * @param body The updated body to be saved
     * @return True on success, false otherwise
     */
    update(id: string, body: QuizAttemptRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/quiz_attempts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload(contentType: string | undefined, contentDisposition: string | undefined, headers: Headers11[] | undefined, length: number | undefined, name: string | undefined, fileNameFormData: string | undefined, fileNameQuery: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/quiz_attempts/upload?";
        if (fileNameQuery === null)
            throw new Error("The parameter 'fileNameQuery' cannot be null.");
        else if (fileNameQuery !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileNameQuery) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType === null || contentType === undefined)
            throw new Error("The parameter 'contentType' cannot be null.");
        else
            content_.append("ContentType", contentType.toString());
        if (contentDisposition === null || contentDisposition === undefined)
            throw new Error("The parameter 'contentDisposition' cannot be null.");
        else
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers === null || headers === undefined)
            throw new Error("The parameter 'headers' cannot be null.");
        else
            headers.forEach(item_ => content_.append("Headers", item_.toString()));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (fileNameFormData === null || fileNameFormData === undefined)
            throw new Error("The parameter 'fileNameFormData' cannot be null.");
        else
            content_.append("FileName", fileNameFormData.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload64(file: string | undefined, fileName: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/quiz_attempts/upload64?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload64(_response);
        });
    }

    protected processUpload64(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

export class QuizAttemptConfigurationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    getAll(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfQuizAttemptConfigurationResponseDto> {
        let url_ = this.baseUrl + "/api/quiz_attempt_configs?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<PagedResultOfQuizAttemptConfigurationResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfQuizAttemptConfigurationResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfQuizAttemptConfigurationResponseDto>(null as any);
    }

    create(body: QuizAttemptConfigurationRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/quiz_attempt_configs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    update(id: string, body: QuizAttemptConfigurationRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/quiz_attempt_configs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Get a record of type T by id
     * @param id The id of the item
     * @return A item T
     */
    get(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/quiz_attempt_configs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Delete a record of type T by id
     * @param id The id of the item to be removed
     * @return True on success, false otherwise
     */
    delete(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/quiz_attempt_configs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload(contentType: string | undefined, contentDisposition: string | undefined, headers: Headers12[] | undefined, length: number | undefined, name: string | undefined, fileNameFormData: string | undefined, fileNameQuery: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/quiz_attempt_configs/upload?";
        if (fileNameQuery === null)
            throw new Error("The parameter 'fileNameQuery' cannot be null.");
        else if (fileNameQuery !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileNameQuery) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType === null || contentType === undefined)
            throw new Error("The parameter 'contentType' cannot be null.");
        else
            content_.append("ContentType", contentType.toString());
        if (contentDisposition === null || contentDisposition === undefined)
            throw new Error("The parameter 'contentDisposition' cannot be null.");
        else
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers === null || headers === undefined)
            throw new Error("The parameter 'headers' cannot be null.");
        else
            headers.forEach(item_ => content_.append("Headers", item_.toString()));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (fileNameFormData === null || fileNameFormData === undefined)
            throw new Error("The parameter 'fileNameFormData' cannot be null.");
        else
            content_.append("FileName", fileNameFormData.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload64(file: string | undefined, fileName: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/quiz_attempt_configs/upload64?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload64(_response);
        });
    }

    protected processUpload64(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

export class UsersClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    updateMe(userRequestDto: UserRequestDto, signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/users/me";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userRequestDto);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateMe(_response);
        });
    }

    protected processUpdateMe(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    me(signal?: AbortSignal): Promise<boolean> {
        let url_ = this.baseUrl + "/api/users/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMe(_response);
        });
    }

    protected processMe(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    getAll(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfUserResponseDto> {
        let url_ = this.baseUrl + "/api/users?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<PagedResultOfUserResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfUserResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfUserResponseDto>(null as any);
    }

    /**
     * Create a record of type T
     * @param body The RequestDto to create object
     * @return The created item T
     */
    create(body: UserRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Get a record of type T by id
     * @param id The id of the item
     * @return A item T
     */
    get(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Delete a record of type T by id
     * @param id The id of the item to be removed
     * @return True on success, false otherwise
     */
    delete(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Update a record of type T by id
     * @param id The id of the item to be updated
     * @param body The updated body to be saved
     * @return True on success, false otherwise
     */
    update(id: string, body: UserRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload(contentType: string | undefined, contentDisposition: string | undefined, headers: Headers13[] | undefined, length: number | undefined, name: string | undefined, fileNameFormData: string | undefined, fileNameQuery: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/users/upload?";
        if (fileNameQuery === null)
            throw new Error("The parameter 'fileNameQuery' cannot be null.");
        else if (fileNameQuery !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileNameQuery) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType === null || contentType === undefined)
            throw new Error("The parameter 'contentType' cannot be null.");
        else
            content_.append("ContentType", contentType.toString());
        if (contentDisposition === null || contentDisposition === undefined)
            throw new Error("The parameter 'contentDisposition' cannot be null.");
        else
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers === null || headers === undefined)
            throw new Error("The parameter 'headers' cannot be null.");
        else
            headers.forEach(item_ => content_.append("Headers", item_.toString()));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (fileNameFormData === null || fileNameFormData === undefined)
            throw new Error("The parameter 'fileNameFormData' cannot be null.");
        else
            content_.append("FileName", fileNameFormData.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload64(file: string | undefined, fileName: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/users/upload64?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload64(_response);
        });
    }

    protected processUpload64(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

export class RankingAnswersResponseDto implements IRankingAnswersResponseDto {
    createdAt?: Date | undefined;
    quizAttemptId?: string | undefined;
    userName?: string | undefined;
    userImage?: string | undefined;
    userSid?: string | undefined;
    questionDisciplineName?: string | undefined;
    questionDisciplineId?: string | undefined;
    questionDisciplineParentId?: string | undefined;
    questionDisciplineParentName?: string | undefined;
    correct!: boolean;
    questionScore!: number;

    constructor(data?: IRankingAnswersResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.quizAttemptId = _data["quizAttemptId"];
            this.userName = _data["userName"];
            this.userImage = _data["userImage"];
            this.userSid = _data["userSid"];
            this.questionDisciplineName = _data["questionDisciplineName"];
            this.questionDisciplineId = _data["questionDisciplineId"];
            this.questionDisciplineParentId = _data["questionDisciplineParentId"];
            this.questionDisciplineParentName = _data["questionDisciplineParentName"];
            this.correct = _data["correct"];
            this.questionScore = _data["questionScore"];
        }
    }

    static fromJS(data: any): RankingAnswersResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new RankingAnswersResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["quizAttemptId"] = this.quizAttemptId;
        data["userName"] = this.userName;
        data["userImage"] = this.userImage;
        data["userSid"] = this.userSid;
        data["questionDisciplineName"] = this.questionDisciplineName;
        data["questionDisciplineId"] = this.questionDisciplineId;
        data["questionDisciplineParentId"] = this.questionDisciplineParentId;
        data["questionDisciplineParentName"] = this.questionDisciplineParentName;
        data["correct"] = this.correct;
        data["questionScore"] = this.questionScore;
        return data;
    }
}

export interface IRankingAnswersResponseDto {
    createdAt?: Date | undefined;
    quizAttemptId?: string | undefined;
    userName?: string | undefined;
    userImage?: string | undefined;
    userSid?: string | undefined;
    questionDisciplineName?: string | undefined;
    questionDisciplineId?: string | undefined;
    questionDisciplineParentId?: string | undefined;
    questionDisciplineParentName?: string | undefined;
    correct: boolean;
    questionScore: number;
}

/** PagedResult */
export class PagedResult implements IPagedResult {
    /** Gets or sets the queryable. */
    queryable!: Queryable[];
    /** Gets or sets the current page. */
    currentPage!: number;
    /** Gets or sets the page count. */
    pageCount!: number;
    /** Gets or sets the size of the page. */
    pageSize!: number;
    /** Gets or sets the row count. */
    rowCount!: number;

    constructor(data?: IPagedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.queryable = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(item);
            }
            this.currentPage = _data["currentPage"];
            this.pageCount = _data["pageCount"];
            this.pageSize = _data["pageSize"];
            this.rowCount = _data["rowCount"];
        }
    }

    static fromJS(data: any): PagedResult {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item);
        }
        data["currentPage"] = this.currentPage;
        data["pageCount"] = this.pageCount;
        data["pageSize"] = this.pageSize;
        data["rowCount"] = this.rowCount;
        return data;
    }
}

/** PagedResult */
export interface IPagedResult {
    /** Gets or sets the queryable. */
    queryable: Queryable[];
    /** Gets or sets the current page. */
    currentPage: number;
    /** Gets or sets the page count. */
    pageCount: number;
    /** Gets or sets the size of the page. */
    pageSize: number;
    /** Gets or sets the row count. */
    rowCount: number;
}

/** PagedResult{TSource} */
export class PagedResultOfAnswerResponseDto extends PagedResult implements IPagedResultOfAnswerResponseDto {
    queryable!: AnswerResponseDto[];

    constructor(data?: IPagedResultOfAnswerResponseDto) {
        super(data);
        if (!data) {
            this.queryable = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(AnswerResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PagedResultOfAnswerResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfAnswerResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** PagedResult{TSource} */
export interface IPagedResultOfAnswerResponseDto extends IPagedResult {
    queryable: AnswerResponseDto[];
}

export class AnswerRequestDto implements IAnswerRequestDto {
    id!: string;
    questionId?: string | undefined;
    alternativeId?: string | undefined;
    correct!: boolean;
    quizAttemptId?: string | undefined;

    constructor(data?: IAnswerRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.questionId = _data["questionId"];
            this.alternativeId = _data["alternativeId"];
            this.correct = _data["correct"];
            this.quizAttemptId = _data["quizAttemptId"];
        }
    }

    static fromJS(data: any): AnswerRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new AnswerRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionId"] = this.questionId;
        data["alternativeId"] = this.alternativeId;
        data["correct"] = this.correct;
        data["quizAttemptId"] = this.quizAttemptId;
        return data;
    }
}

export interface IAnswerRequestDto {
    id: string;
    questionId?: string | undefined;
    alternativeId?: string | undefined;
    correct: boolean;
    quizAttemptId?: string | undefined;
}

export class AnswerResponseDto extends AnswerRequestDto implements IAnswerResponseDto {
    question?: QuestionResponseDto | undefined;
    alternative?: AlternativeResponseDto | undefined;
    quizAttempt?: QuizAttemptResponseDto | undefined;
    userId?: string | undefined;
    user!: UserResponseDto;
    userName?: string | undefined;
    correctId?: string | undefined;
    complete!: boolean;
    questionDisciplineName?: string | undefined;
    questionDisciplineId?: string | undefined;
    isCorrect!: boolean;

    constructor(data?: IAnswerResponseDto) {
        super(data);
        if (!data) {
            this.user = new UserResponseDto();
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.question = _data["question"] ? QuestionResponseDto.fromJS(_data["question"]) : <any>undefined;
            this.alternative = _data["alternative"] ? AlternativeResponseDto.fromJS(_data["alternative"]) : <any>undefined;
            this.quizAttempt = _data["quizAttempt"] ? QuizAttemptResponseDto.fromJS(_data["quizAttempt"]) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? UserResponseDto.fromJS(_data["user"]) : new UserResponseDto();
            this.userName = _data["userName"];
            this.correctId = _data["correctId"];
            this.complete = _data["complete"];
            this.questionDisciplineName = _data["questionDisciplineName"];
            this.questionDisciplineId = _data["questionDisciplineId"];
            this.isCorrect = _data["isCorrect"];
        }
    }

    static override fromJS(data: any): AnswerResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new AnswerResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["question"] = this.question ? this.question.toJSON() : <any>undefined;
        data["alternative"] = this.alternative ? this.alternative.toJSON() : <any>undefined;
        data["quizAttempt"] = this.quizAttempt ? this.quizAttempt.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        data["correctId"] = this.correctId;
        data["complete"] = this.complete;
        data["questionDisciplineName"] = this.questionDisciplineName;
        data["questionDisciplineId"] = this.questionDisciplineId;
        data["isCorrect"] = this.isCorrect;
        super.toJSON(data);
        return data;
    }
}

export interface IAnswerResponseDto extends IAnswerRequestDto {
    question?: QuestionResponseDto | undefined;
    alternative?: AlternativeResponseDto | undefined;
    quizAttempt?: QuizAttemptResponseDto | undefined;
    userId?: string | undefined;
    user: UserResponseDto;
    userName?: string | undefined;
    correctId?: string | undefined;
    complete: boolean;
    questionDisciplineName?: string | undefined;
    questionDisciplineId?: string | undefined;
    isCorrect: boolean;
}

export class QuestionRequestDto implements IQuestionRequestDto {
    id!: string;
    year!: number;
    board!: string;
    image?: string | undefined;
    text?: string | undefined;
    score!: number;
    active!: boolean;
    questionNumber?: number | undefined;
    institutionId?: string | undefined;
    questionBankId?: string | undefined;
    quizAttemptId?: string | undefined;
    disciplineId?: string | undefined;
    alternatives?: AlternativeRequestDto[] | undefined;
    discipline?: DisciplineRequestDto | undefined;
    isValid!: boolean;

    constructor(data?: IQuestionRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.year = _data["year"];
            this.board = _data["board"];
            this.image = _data["image"];
            this.text = _data["text"];
            this.score = _data["score"];
            this.active = _data["active"];
            this.questionNumber = _data["questionNumber"];
            this.institutionId = _data["institutionId"];
            this.questionBankId = _data["questionBankId"];
            this.quizAttemptId = _data["quizAttemptId"];
            this.disciplineId = _data["disciplineId"];
            if (Array.isArray(_data["alternatives"])) {
                this.alternatives = [] as any;
                for (let item of _data["alternatives"])
                    this.alternatives!.push(AlternativeRequestDto.fromJS(item));
            }
            this.discipline = _data["discipline"] ? DisciplineRequestDto.fromJS(_data["discipline"]) : <any>undefined;
            this.isValid = _data["isValid"];
        }
    }

    static fromJS(data: any): QuestionRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["year"] = this.year;
        data["board"] = this.board;
        data["image"] = this.image;
        data["text"] = this.text;
        data["score"] = this.score;
        data["active"] = this.active;
        data["questionNumber"] = this.questionNumber;
        data["institutionId"] = this.institutionId;
        data["questionBankId"] = this.questionBankId;
        data["quizAttemptId"] = this.quizAttemptId;
        data["disciplineId"] = this.disciplineId;
        if (Array.isArray(this.alternatives)) {
            data["alternatives"] = [];
            for (let item of this.alternatives)
                data["alternatives"].push(item.toJSON());
        }
        data["discipline"] = this.discipline ? this.discipline.toJSON() : <any>undefined;
        data["isValid"] = this.isValid;
        return data;
    }
}

export interface IQuestionRequestDto {
    id: string;
    year: number;
    board: string;
    image?: string | undefined;
    text?: string | undefined;
    score: number;
    active: boolean;
    questionNumber?: number | undefined;
    institutionId?: string | undefined;
    questionBankId?: string | undefined;
    quizAttemptId?: string | undefined;
    disciplineId?: string | undefined;
    alternatives?: AlternativeRequestDto[] | undefined;
    discipline?: DisciplineRequestDto | undefined;
    isValid: boolean;
}

export class QuestionResponseDto extends QuestionRequestDto implements IQuestionResponseDto {
    alternatives!: AlternativeResponseDto[];
    observations!: ObservationResponseDto[];
    answers!: AnswerResponseDto[];
    observationRequests!: ObservationRequestResponseDto[];
    discipline!: DisciplineResponseDto;
    questionNumber!: number;
    disciplineName!: string;
    disciplineParentName!: string;
    institutionName!: string;
    alternativesCount!: number;
    observationsCount!: number;
    answersCount!: number;
    answersCorrectCount!: number;
    observationRequestsCount!: number;
    correctId?: string | undefined;

    constructor(data?: IQuestionResponseDto) {
        super(data);
        if (!data) {
            this.alternatives = [];
            this.observations = [];
            this.answers = [];
            this.observationRequests = [];
            this.discipline = new DisciplineResponseDto();
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["alternatives"])) {
                this.alternatives = [] as any;
                for (let item of _data["alternatives"])
                    this.alternatives!.push(AlternativeResponseDto.fromJS(item));
            }
            if (Array.isArray(_data["observations"])) {
                this.observations = [] as any;
                for (let item of _data["observations"])
                    this.observations!.push(ObservationResponseDto.fromJS(item));
            }
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(AnswerResponseDto.fromJS(item));
            }
            if (Array.isArray(_data["observationRequests"])) {
                this.observationRequests = [] as any;
                for (let item of _data["observationRequests"])
                    this.observationRequests!.push(ObservationRequestResponseDto.fromJS(item));
            }
            this.discipline = _data["discipline"] ? DisciplineResponseDto.fromJS(_data["discipline"]) : new DisciplineResponseDto();
            this.questionNumber = _data["questionNumber"];
            this.disciplineName = _data["disciplineName"];
            this.disciplineParentName = _data["disciplineParentName"];
            this.institutionName = _data["institutionName"];
            this.alternativesCount = _data["alternativesCount"];
            this.observationsCount = _data["observationsCount"];
            this.answersCount = _data["answersCount"];
            this.answersCorrectCount = _data["answersCorrectCount"];
            this.observationRequestsCount = _data["observationRequestsCount"];
            this.correctId = _data["correctId"];
        }
    }

    static override fromJS(data: any): QuestionResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.alternatives)) {
            data["alternatives"] = [];
            for (let item of this.alternatives)
                data["alternatives"].push(item.toJSON());
        }
        if (Array.isArray(this.observations)) {
            data["observations"] = [];
            for (let item of this.observations)
                data["observations"].push(item.toJSON());
        }
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        if (Array.isArray(this.observationRequests)) {
            data["observationRequests"] = [];
            for (let item of this.observationRequests)
                data["observationRequests"].push(item.toJSON());
        }
        data["discipline"] = this.discipline ? this.discipline.toJSON() : <any>undefined;
        data["questionNumber"] = this.questionNumber;
        data["disciplineName"] = this.disciplineName;
        data["disciplineParentName"] = this.disciplineParentName;
        data["institutionName"] = this.institutionName;
        data["alternativesCount"] = this.alternativesCount;
        data["observationsCount"] = this.observationsCount;
        data["answersCount"] = this.answersCount;
        data["answersCorrectCount"] = this.answersCorrectCount;
        data["observationRequestsCount"] = this.observationRequestsCount;
        data["correctId"] = this.correctId;
        super.toJSON(data);
        return data;
    }
}

export interface IQuestionResponseDto extends IQuestionRequestDto {
    alternatives: AlternativeResponseDto[];
    observations: ObservationResponseDto[];
    answers: AnswerResponseDto[];
    observationRequests: ObservationRequestResponseDto[];
    discipline: DisciplineResponseDto;
    questionNumber: number;
    disciplineName: string;
    disciplineParentName: string;
    institutionName: string;
    alternativesCount: number;
    observationsCount: number;
    answersCount: number;
    answersCorrectCount: number;
    observationRequestsCount: number;
    correctId?: string | undefined;
}

export class AlternativeResponseDto implements IAlternativeResponseDto {
    id?: string | undefined;
    questionId?: string | undefined;
    text!: string;
    aiExplanation!: string;
    question?: QuestionResponseDto | undefined;
    questionText!: string;
    answers!: AnswerResponseDto[];
    answersCount!: number;

    constructor(data?: IAlternativeResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.answers = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.questionId = _data["questionId"];
            this.text = _data["text"];
            this.aiExplanation = _data["aiExplanation"];
            this.question = _data["question"] ? QuestionResponseDto.fromJS(_data["question"]) : <any>undefined;
            this.questionText = _data["questionText"];
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(AnswerResponseDto.fromJS(item));
            }
            this.answersCount = _data["answersCount"];
        }
    }

    static fromJS(data: any): AlternativeResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlternativeResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionId"] = this.questionId;
        data["text"] = this.text;
        data["aiExplanation"] = this.aiExplanation;
        data["question"] = this.question ? this.question.toJSON() : <any>undefined;
        data["questionText"] = this.questionText;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        data["answersCount"] = this.answersCount;
        return data;
    }
}

export interface IAlternativeResponseDto {
    id?: string | undefined;
    questionId?: string | undefined;
    text: string;
    aiExplanation: string;
    question?: QuestionResponseDto | undefined;
    questionText: string;
    answers: AnswerResponseDto[];
    answersCount: number;
}

export class ObservationRequestDto implements IObservationRequestDto {
    id!: string;
    questionId?: string | undefined;
    type!: ObservationType;
    text!: string;

    constructor(data?: IObservationRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.questionId = _data["questionId"];
            this.type = _data["type"];
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): ObservationRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObservationRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionId"] = this.questionId;
        data["type"] = this.type;
        data["text"] = this.text;
        return data;
    }
}

export interface IObservationRequestDto {
    id: string;
    questionId?: string | undefined;
    type: ObservationType;
    text: string;
}

export class ObservationResponseDto extends ObservationRequestDto implements IObservationResponseDto {
    question?: QuestionResponseDto | undefined;
    userId?: string | undefined;
    user?: UserResponseDto | undefined;

    constructor(data?: IObservationResponseDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.question = _data["question"] ? QuestionResponseDto.fromJS(_data["question"]) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? UserResponseDto.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ObservationResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObservationResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["question"] = this.question ? this.question.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IObservationResponseDto extends IObservationRequestDto {
    question?: QuestionResponseDto | undefined;
    userId?: string | undefined;
    user?: UserResponseDto | undefined;
}

export class UserRequestDto implements IUserRequestDto {
    id?: string | undefined;
    name!: string;
    address?: string | undefined;
    birthDay?: Date | undefined;
    image?: string | undefined;
    email!: string;
    phoneNumber?: string | undefined;
    role?: string | undefined;
    sid?: string | undefined;
    crewId?: string | undefined;

    constructor(data?: IUserRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.address = _data["address"];
            this.birthDay = _data["birthDay"] ? new Date(_data["birthDay"].toString()) : <any>undefined;
            this.image = _data["image"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.role = _data["role"];
            this.sid = _data["sid"];
            this.crewId = _data["crewId"];
        }
    }

    static fromJS(data: any): UserRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["address"] = this.address;
        data["birthDay"] = this.birthDay ? this.birthDay.toISOString() : <any>undefined;
        data["image"] = this.image;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["role"] = this.role;
        data["sid"] = this.sid;
        data["crewId"] = this.crewId;
        return data;
    }
}

export interface IUserRequestDto {
    id?: string | undefined;
    name: string;
    address?: string | undefined;
    birthDay?: Date | undefined;
    image?: string | undefined;
    email: string;
    phoneNumber?: string | undefined;
    role?: string | undefined;
    sid?: string | undefined;
    crewId?: string | undefined;
}

export class UserResponseDto extends UserRequestDto implements IUserResponseDto {
    enrollments?: EnrollmentRequestDto[] | undefined;
    enrollmentsCount!: number;

    constructor(data?: IUserResponseDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["enrollments"])) {
                this.enrollments = [] as any;
                for (let item of _data["enrollments"])
                    this.enrollments!.push(EnrollmentRequestDto.fromJS(item));
            }
            this.enrollmentsCount = _data["enrollmentsCount"];
        }
    }

    static override fromJS(data: any): UserResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.enrollments)) {
            data["enrollments"] = [];
            for (let item of this.enrollments)
                data["enrollments"].push(item.toJSON());
        }
        data["enrollmentsCount"] = this.enrollmentsCount;
        super.toJSON(data);
        return data;
    }
}

export interface IUserResponseDto extends IUserRequestDto {
    enrollments?: EnrollmentRequestDto[] | undefined;
    enrollmentsCount: number;
}

export class EnrollmentRequestDto implements IEnrollmentRequestDto {
    id?: string | undefined;
    studentId?: string | undefined;
    crewId?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    active!: boolean;

    constructor(data?: IEnrollmentRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.studentId = _data["studentId"];
            this.crewId = _data["crewId"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): EnrollmentRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnrollmentRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["studentId"] = this.studentId;
        data["crewId"] = this.crewId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["active"] = this.active;
        return data;
    }
}

export interface IEnrollmentRequestDto {
    id?: string | undefined;
    studentId?: string | undefined;
    crewId?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    active: boolean;
}

export type ObservationType = 0 | 1;

export class ObservationRequestRequestDto implements IObservationRequestRequestDto {
    id?: string | undefined;
    questionId?: string | undefined;
    resolved?: boolean | undefined;
    type!: ObservationType;
    text!: string;

    constructor(data?: IObservationRequestRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.questionId = _data["questionId"];
            this.resolved = _data["resolved"];
            this.type = _data["type"];
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): ObservationRequestRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObservationRequestRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionId"] = this.questionId;
        data["resolved"] = this.resolved;
        data["type"] = this.type;
        data["text"] = this.text;
        return data;
    }
}

export interface IObservationRequestRequestDto {
    id?: string | undefined;
    questionId?: string | undefined;
    resolved?: boolean | undefined;
    type: ObservationType;
    text: string;
}

export class ObservationRequestResponseDto extends ObservationRequestRequestDto implements IObservationRequestResponseDto {
    question?: QuestionResponseDto | undefined;
    observations!: ObservationResponseDto[];
    observationsCount!: number;
    userId?: string | undefined;
    user?: UserResponseDto | undefined;

    constructor(data?: IObservationRequestResponseDto) {
        super(data);
        if (!data) {
            this.observations = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.question = _data["question"] ? QuestionResponseDto.fromJS(_data["question"]) : <any>undefined;
            if (Array.isArray(_data["observations"])) {
                this.observations = [] as any;
                for (let item of _data["observations"])
                    this.observations!.push(ObservationResponseDto.fromJS(item));
            }
            this.observationsCount = _data["observationsCount"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? UserResponseDto.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ObservationRequestResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObservationRequestResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["question"] = this.question ? this.question.toJSON() : <any>undefined;
        if (Array.isArray(this.observations)) {
            data["observations"] = [];
            for (let item of this.observations)
                data["observations"].push(item.toJSON());
        }
        data["observationsCount"] = this.observationsCount;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IObservationRequestResponseDto extends IObservationRequestRequestDto {
    question?: QuestionResponseDto | undefined;
    observations: ObservationResponseDto[];
    observationsCount: number;
    userId?: string | undefined;
    user?: UserResponseDto | undefined;
}

export class DisciplineRequestDto implements IDisciplineRequestDto {
    id!: string;
    name!: string;
    description!: string;
    image?: string | undefined;
    parentId?: string | undefined;

    constructor(data?: IDisciplineRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.image = _data["image"];
            this.parentId = _data["parentId"];
        }
    }

    static fromJS(data: any): DisciplineRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new DisciplineRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["image"] = this.image;
        data["parentId"] = this.parentId;
        return data;
    }
}

export interface IDisciplineRequestDto {
    id: string;
    name: string;
    description: string;
    image?: string | undefined;
    parentId?: string | undefined;
}

export class DisciplineResponseDto extends DisciplineRequestDto implements IDisciplineResponseDto {
    parentName!: string;
    childsCount!: number;
    parent?: DisciplineResponseDto | undefined;
    childs!: DisciplineResponseDto[];
    questions!: QuestionResponseDto[];

    constructor(data?: IDisciplineResponseDto) {
        super(data);
        if (!data) {
            this.childs = [];
            this.questions = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.parentName = _data["parentName"];
            this.childsCount = _data["childsCount"];
            this.parent = _data["parent"] ? DisciplineResponseDto.fromJS(_data["parent"]) : <any>undefined;
            if (Array.isArray(_data["childs"])) {
                this.childs = [] as any;
                for (let item of _data["childs"])
                    this.childs!.push(DisciplineResponseDto.fromJS(item));
            }
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(QuestionResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): DisciplineResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new DisciplineResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["childsCount"] = this.childsCount;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        if (Array.isArray(this.childs)) {
            data["childs"] = [];
            for (let item of this.childs)
                data["childs"].push(item.toJSON());
        }
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IDisciplineResponseDto extends IDisciplineRequestDto {
    parentName: string;
    childsCount: number;
    parent?: DisciplineResponseDto | undefined;
    childs: DisciplineResponseDto[];
    questions: QuestionResponseDto[];
}

export class AlternativeRequestDto implements IAlternativeRequestDto {
    id?: string | undefined;
    questionId?: string | undefined;
    text!: string;
    correct!: boolean;
    aiExplanation!: string;

    constructor(data?: IAlternativeRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.questionId = _data["questionId"];
            this.text = _data["text"];
            this.correct = _data["correct"];
            this.aiExplanation = _data["aiExplanation"];
        }
    }

    static fromJS(data: any): AlternativeRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlternativeRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionId"] = this.questionId;
        data["text"] = this.text;
        data["correct"] = this.correct;
        data["aiExplanation"] = this.aiExplanation;
        return data;
    }
}

export interface IAlternativeRequestDto {
    id?: string | undefined;
    questionId?: string | undefined;
    text: string;
    correct: boolean;
    aiExplanation: string;
}

export class QuizAttemptRequestDto implements IQuizAttemptRequestDto {
    id!: string;
    startedAt!: Date;
    finishedAt?: Date | undefined;
    dConfigureServicesuration?: string | undefined;
    score!: number;
    total!: number;
    passed!: boolean;

    constructor(data?: IQuizAttemptRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.startedAt = _data["startedAt"] ? new Date(_data["startedAt"].toString()) : <any>undefined;
            this.finishedAt = _data["finishedAt"] ? new Date(_data["finishedAt"].toString()) : <any>undefined;
            this.dConfigureServicesuration = _data["dConfigureServicesuration"];
            this.score = _data["score"];
            this.total = _data["total"];
            this.passed = _data["passed"];
        }
    }

    static fromJS(data: any): QuizAttemptRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuizAttemptRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["startedAt"] = this.startedAt ? this.startedAt.toISOString() : <any>undefined;
        data["finishedAt"] = this.finishedAt ? this.finishedAt.toISOString() : <any>undefined;
        data["dConfigureServicesuration"] = this.dConfigureServicesuration;
        data["score"] = this.score;
        data["total"] = this.total;
        data["passed"] = this.passed;
        return data;
    }
}

export interface IQuizAttemptRequestDto {
    id: string;
    startedAt: Date;
    finishedAt?: Date | undefined;
    dConfigureServicesuration?: string | undefined;
    score: number;
    total: number;
    passed: boolean;
}

export class QuizAttemptResponseDto extends QuizAttemptRequestDto implements IQuizAttemptResponseDto {
    questions!: QuestionResponseDto[];
    answers!: AnswerResponseDto[];

    constructor(data?: IQuizAttemptResponseDto) {
        super(data);
        if (!data) {
            this.questions = [];
            this.answers = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(QuestionResponseDto.fromJS(item));
            }
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(AnswerResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): QuizAttemptResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuizAttemptResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IQuizAttemptResponseDto extends IQuizAttemptRequestDto {
    questions: QuestionResponseDto[];
    answers: AnswerResponseDto[];
}

export class Message implements IMessage {
    text?: string | undefined;

    constructor(data?: IMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): Message {
        data = typeof data === 'object' ? data : {};
        let result = new Message();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        return data;
    }
}

export interface IMessage {
    text?: string | undefined;
}

/** Contains common elements used for both constructing User-related requests, and comprising User-related responses. */
export abstract class UserBase implements IUserBase {
    /** Contains user meta data. The user has read-only access to this. */
    app_metadata?: any | undefined;
    /** Gets or sets the user's email address. */
    email?: string | undefined;
    /** Gets or sets whether the user's email address is verified. */
    email_verified?: boolean | undefined;
    /** Gets or sets the user's phone number. */
    phone_number?: string | undefined;
    /** Gets or sets whether the user's phone is verified. */
    phone_verified?: boolean | undefined;
    /** Contains user meta data. The user has read/write access to this. */
    user_metadata?: any | undefined;
    /** Gets or sets the user' username. */
    username?: string | undefined;
    /** The Nickname of the user. */
    nickname?: string | undefined;
    /** The first name of the user (if available). */
    given_name?: string | undefined;
    /** The full name of the user (e.g.: John Foo). ALWAYS GENERATED. */
    name?: string | undefined;
    /** The last name of the user (if available). */
    family_name?: string | undefined;
    /** URL pointing to the user picture (if not available, will use gravatar.com with the email). ALWAYS GENERATED */
    picture?: string | undefined;
    /** Gets or sets whether the user is blocked. True if the user is blocked, otherwise false. */
    blocked?: boolean | undefined;

    constructor(data?: IUserBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.app_metadata = _data["app_metadata"];
            this.email = _data["email"];
            this.email_verified = _data["email_verified"];
            this.phone_number = _data["phone_number"];
            this.phone_verified = _data["phone_verified"];
            this.user_metadata = _data["user_metadata"];
            this.username = _data["username"];
            this.nickname = _data["nickname"];
            this.given_name = _data["given_name"];
            this.name = _data["name"];
            this.family_name = _data["family_name"];
            this.picture = _data["picture"];
            this.blocked = _data["blocked"];
        }
    }

    static fromJS(data: any): UserBase {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'UserBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["app_metadata"] = this.app_metadata;
        data["email"] = this.email;
        data["email_verified"] = this.email_verified;
        data["phone_number"] = this.phone_number;
        data["phone_verified"] = this.phone_verified;
        data["user_metadata"] = this.user_metadata;
        data["username"] = this.username;
        data["nickname"] = this.nickname;
        data["given_name"] = this.given_name;
        data["name"] = this.name;
        data["family_name"] = this.family_name;
        data["picture"] = this.picture;
        data["blocked"] = this.blocked;
        return data;
    }
}

/** Contains common elements used for both constructing User-related requests, and comprising User-related responses. */
export interface IUserBase {
    /** Contains user meta data. The user has read-only access to this. */
    app_metadata?: any | undefined;
    /** Gets or sets the user's email address. */
    email?: string | undefined;
    /** Gets or sets whether the user's email address is verified. */
    email_verified?: boolean | undefined;
    /** Gets or sets the user's phone number. */
    phone_number?: string | undefined;
    /** Gets or sets whether the user's phone is verified. */
    phone_verified?: boolean | undefined;
    /** Contains user meta data. The user has read/write access to this. */
    user_metadata?: any | undefined;
    /** Gets or sets the user' username. */
    username?: string | undefined;
    /** The Nickname of the user. */
    nickname?: string | undefined;
    /** The first name of the user (if available). */
    given_name?: string | undefined;
    /** The full name of the user (e.g.: John Foo). ALWAYS GENERATED. */
    name?: string | undefined;
    /** The last name of the user (if available). */
    family_name?: string | undefined;
    /** URL pointing to the user picture (if not available, will use gravatar.com with the email). ALWAYS GENERATED */
    picture?: string | undefined;
    /** Gets or sets whether the user is blocked. True if the user is blocked, otherwise false. */
    blocked?: boolean | undefined;
}

/** Represents the request to create a User. */
export class UserCreateRequest extends UserBase implements IUserCreateRequest {
    /** Gets or sets the connection the user belongs to. */
    connection?: string | undefined;
    /** Gets or sets the (optional) id of the user */
    user_id?: string | undefined;
    /** Gets or sets the user's password. This is mandatory only for auth0 connection strategy. */
    password?: string | undefined;
    /** Gets or sets whether the user's email change must be verified. True if it must be verified, otherwise false. */
    verify_email?: boolean | undefined;

    constructor(data?: IUserCreateRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.connection = _data["connection"];
            this.user_id = _data["user_id"];
            this.password = _data["password"];
            this.verify_email = _data["verify_email"];
        }
    }

    static override fromJS(data: any): UserCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserCreateRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connection"] = this.connection;
        data["user_id"] = this.user_id;
        data["password"] = this.password;
        data["verify_email"] = this.verify_email;
        super.toJSON(data);
        return data;
    }
}

/** Represents the request to create a User. */
export interface IUserCreateRequest extends IUserBase {
    /** Gets or sets the connection the user belongs to. */
    connection?: string | undefined;
    /** Gets or sets the (optional) id of the user */
    user_id?: string | undefined;
    /** Gets or sets the user's password. This is mandatory only for auth0 connection strategy. */
    password?: string | undefined;
    /** Gets or sets whether the user's email change must be verified. True if it must be verified, otherwise false. */
    verify_email?: boolean | undefined;
}

/** Base class for user maintenance requests. */
export class UserMaintenanceRequestBase implements IUserMaintenanceRequestBase {
    /** Client ID of the application. */
    client_id?: string | undefined;
    /** Name of the connection. */
    connection?: string | undefined;
    /** Email address of the user. */
    email?: string | undefined;

    constructor(data?: IUserMaintenanceRequestBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.client_id = _data["client_id"];
            this.connection = _data["connection"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): UserMaintenanceRequestBase {
        data = typeof data === 'object' ? data : {};
        let result = new UserMaintenanceRequestBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["client_id"] = this.client_id;
        data["connection"] = this.connection;
        data["email"] = this.email;
        return data;
    }
}

/** Base class for user maintenance requests. */
export interface IUserMaintenanceRequestBase {
    /** Client ID of the application. */
    client_id?: string | undefined;
    /** Name of the connection. */
    connection?: string | undefined;
    /** Email address of the user. */
    email?: string | undefined;
}

/** Represents a request to sign up a new user. */
export class SignupUserRequest extends UserMaintenanceRequestBase implements ISignupUserRequest {
    /** Initial password for this user. */
    password?: string | undefined;
    /** Username of this user. Only valid if the connection requires a username. */
    username?: string | undefined;
    /** Given name for this user. */
    given_name?: string | undefined;
    /** Family name for this user. */
    family_name?: string | undefined;
    /** Name of this user. */
    name?: string | undefined;
    /** Nickname of this user. */
    nickname?: string | undefined;
    /** URL to a picture of this user. */
    picture?: string | undefined;
    /** Metadata the user has read/write access to.  */
    user_metadata?: any | undefined;

    constructor(data?: ISignupUserRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.password = _data["password"];
            this.username = _data["username"];
            this.given_name = _data["given_name"];
            this.family_name = _data["family_name"];
            this.name = _data["name"];
            this.nickname = _data["nickname"];
            this.picture = _data["picture"];
            this.user_metadata = _data["user_metadata"];
        }
    }

    static override fromJS(data: any): SignupUserRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SignupUserRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["username"] = this.username;
        data["given_name"] = this.given_name;
        data["family_name"] = this.family_name;
        data["name"] = this.name;
        data["nickname"] = this.nickname;
        data["picture"] = this.picture;
        data["user_metadata"] = this.user_metadata;
        super.toJSON(data);
        return data;
    }
}

/** Represents a request to sign up a new user. */
export interface ISignupUserRequest extends IUserMaintenanceRequestBase {
    /** Initial password for this user. */
    password?: string | undefined;
    /** Username of this user. Only valid if the connection requires a username. */
    username?: string | undefined;
    /** Given name for this user. */
    given_name?: string | undefined;
    /** Family name for this user. */
    family_name?: string | undefined;
    /** Name of this user. */
    name?: string | undefined;
    /** Nickname of this user. */
    nickname?: string | undefined;
    /** URL to a picture of this user. */
    picture?: string | undefined;
    /** Metadata the user has read/write access to.  */
    user_metadata?: any | undefined;
}

/** Specifies pagination info to use when requesting paged results. */
export class PaginationInfo implements IPaginationInfo {
    /** Return results with a total result count (true) or with no totals (false, default). */
    includeTotals!: boolean;
    /** Number of results per page. */
    perPage!: number;
    /** Page index of the results to return. First page is 0. */
    pageNo!: number;

    constructor(data?: IPaginationInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.includeTotals = _data["includeTotals"];
            this.perPage = _data["perPage"];
            this.pageNo = _data["pageNo"];
        }
    }

    static fromJS(data: any): PaginationInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PaginationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["includeTotals"] = this.includeTotals;
        data["perPage"] = this.perPage;
        data["pageNo"] = this.pageNo;
        return data;
    }
}

/** Specifies pagination info to use when requesting paged results. */
export interface IPaginationInfo {
    /** Return results with a total result count (true) or with no totals (false, default). */
    includeTotals: boolean;
    /** Number of results per page. */
    perPage: number;
    /** Page index of the results to return. First page is 0. */
    pageNo: number;
}

/** Contains details of permissions that should be assigned to a role. */
export class AssignPermissionsRequest implements IAssignPermissionsRequest {
    /** User IDs to assign to the role. */
    permissions?: PermissionIdentity[] | undefined;

    constructor(data?: IAssignPermissionsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionIdentity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AssignPermissionsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AssignPermissionsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }
}

/** Contains details of permissions that should be assigned to a role. */
export interface IAssignPermissionsRequest {
    /** User IDs to assign to the role. */
    permissions?: PermissionIdentity[] | undefined;
}

/** Represents the properties of a permission that give it its unique identity. */
export class PermissionIdentity implements IPermissionIdentity {
    /** The resource server that the permission is attached to. */
    resource_server_identifier?: string | undefined;
    /** The name of the permission. */
    permission_name?: string | undefined;

    constructor(data?: IPermissionIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resource_server_identifier = _data["resource_server_identifier"];
            this.permission_name = _data["permission_name"];
        }
    }

    static fromJS(data: any): PermissionIdentity {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionIdentity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resource_server_identifier"] = this.resource_server_identifier;
        data["permission_name"] = this.permission_name;
        return data;
    }
}

/** Represents the properties of a permission that give it its unique identity. */
export interface IPermissionIdentity {
    /** The resource server that the permission is attached to. */
    resource_server_identifier?: string | undefined;
    /** The name of the permission. */
    permission_name?: string | undefined;
}

/** Contains details of roles that should be assigned to a user. */
export class AssignRolesRequest implements IAssignRolesRequest {
    /** Role IDs to assign to the user. */
    roles?: string[] | undefined;

    constructor(data?: IAssignRolesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): AssignRolesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AssignRolesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

/** Contains details of roles that should be assigned to a user. */
export interface IAssignRolesRequest {
    /** Role IDs to assign to the user. */
    roles?: string[] | undefined;
}

/** PagedResult{TSource} */
export class PagedResultOfConfigResponseDto extends PagedResult implements IPagedResultOfConfigResponseDto {
    queryable!: ConfigResponseDto[];

    constructor(data?: IPagedResultOfConfigResponseDto) {
        super(data);
        if (!data) {
            this.queryable = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(ConfigResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PagedResultOfConfigResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfConfigResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** PagedResult{TSource} */
export interface IPagedResultOfConfigResponseDto extends IPagedResult {
    queryable: ConfigResponseDto[];
}

export class ConfigRequestDto implements IConfigRequestDto {
    id?: string | undefined;
    key!: string;
    value!: string;

    constructor(data?: IConfigRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ConfigRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IConfigRequestDto {
    id?: string | undefined;
    key: string;
    value: string;
}

export class ConfigResponseDto extends ConfigRequestDto implements IConfigResponseDto {

    constructor(data?: IConfigResponseDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): ConfigResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IConfigResponseDto extends IConfigRequestDto {
}

/** PagedResult{TSource} */
export class PagedResultOfCrewResponseDto extends PagedResult implements IPagedResultOfCrewResponseDto {
    queryable!: CrewResponseDto[];

    constructor(data?: IPagedResultOfCrewResponseDto) {
        super(data);
        if (!data) {
            this.queryable = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(CrewResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PagedResultOfCrewResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfCrewResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** PagedResult{TSource} */
export interface IPagedResultOfCrewResponseDto extends IPagedResult {
    queryable: CrewResponseDto[];
}

export class CrewRequestDto implements ICrewRequestDto {
    id?: string | undefined;
    name!: string;
    description!: string;
    data?: string | undefined;

    constructor(data?: ICrewRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): CrewRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CrewRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["data"] = this.data;
        return data;
    }
}

export interface ICrewRequestDto {
    id?: string | undefined;
    name: string;
    description: string;
    data?: string | undefined;
}

export class CrewResponseDto extends CrewRequestDto implements ICrewResponseDto {

    constructor(data?: ICrewResponseDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): CrewResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CrewResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICrewResponseDto extends ICrewRequestDto {
}

/** PagedResult{TSource} */
export class PagedResultOfDisciplineResponseDto extends PagedResult implements IPagedResultOfDisciplineResponseDto {
    queryable!: DisciplineResponseDto[];

    constructor(data?: IPagedResultOfDisciplineResponseDto) {
        super(data);
        if (!data) {
            this.queryable = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(DisciplineResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PagedResultOfDisciplineResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfDisciplineResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** PagedResult{TSource} */
export interface IPagedResultOfDisciplineResponseDto extends IPagedResult {
    queryable: DisciplineResponseDto[];
}

/** PagedResult{TSource} */
export class PagedResultOfEnrollmentResponseDto extends PagedResult implements IPagedResultOfEnrollmentResponseDto {
    queryable!: EnrollmentResponseDto[];

    constructor(data?: IPagedResultOfEnrollmentResponseDto) {
        super(data);
        if (!data) {
            this.queryable = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(EnrollmentResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PagedResultOfEnrollmentResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfEnrollmentResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** PagedResult{TSource} */
export interface IPagedResultOfEnrollmentResponseDto extends IPagedResult {
    queryable: EnrollmentResponseDto[];
}

export class EnrollmentResponseDto extends EnrollmentRequestDto implements IEnrollmentResponseDto {
    student?: UserRequestDto | undefined;
    crew?: CrewRequestDto | undefined;
    studentName!: string;
    crewName!: string;

    constructor(data?: IEnrollmentResponseDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.student = _data["student"] ? UserRequestDto.fromJS(_data["student"]) : <any>undefined;
            this.crew = _data["crew"] ? CrewRequestDto.fromJS(_data["crew"]) : <any>undefined;
            this.studentName = _data["studentName"];
            this.crewName = _data["crewName"];
        }
    }

    static override fromJS(data: any): EnrollmentResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnrollmentResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["student"] = this.student ? this.student.toJSON() : <any>undefined;
        data["crew"] = this.crew ? this.crew.toJSON() : <any>undefined;
        data["studentName"] = this.studentName;
        data["crewName"] = this.crewName;
        super.toJSON(data);
        return data;
    }
}

export interface IEnrollmentResponseDto extends IEnrollmentRequestDto {
    student?: UserRequestDto | undefined;
    crew?: CrewRequestDto | undefined;
    studentName: string;
    crewName: string;
}

/** PagedResult{TSource} */
export class PagedResultOfInstitutionResponseDto extends PagedResult implements IPagedResultOfInstitutionResponseDto {
    queryable!: InstitutionResponseDto[];

    constructor(data?: IPagedResultOfInstitutionResponseDto) {
        super(data);
        if (!data) {
            this.queryable = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(InstitutionResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PagedResultOfInstitutionResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfInstitutionResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** PagedResult{TSource} */
export interface IPagedResultOfInstitutionResponseDto extends IPagedResult {
    queryable: InstitutionResponseDto[];
}

export class InstitutionRequestDto implements IInstitutionRequestDto {
    id!: string;
    name!: string;
    state!: string;
    stadual!: boolean;
    privateInstitution!: boolean;

    constructor(data?: IInstitutionRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.state = _data["state"];
            this.stadual = _data["stadual"];
            this.privateInstitution = _data["privateInstitution"];
        }
    }

    static fromJS(data: any): InstitutionRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstitutionRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["state"] = this.state;
        data["stadual"] = this.stadual;
        data["privateInstitution"] = this.privateInstitution;
        return data;
    }
}

export interface IInstitutionRequestDto {
    id: string;
    name: string;
    state: string;
    stadual: boolean;
    privateInstitution: boolean;
}

export class InstitutionResponseDto extends InstitutionRequestDto implements IInstitutionResponseDto {
    questions!: QuestionResponseDto[];
    questionBanks!: QuestionBankResponseDto[];

    constructor(data?: IInstitutionResponseDto) {
        super(data);
        if (!data) {
            this.questions = [];
            this.questionBanks = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(QuestionResponseDto.fromJS(item));
            }
            if (Array.isArray(_data["questionBanks"])) {
                this.questionBanks = [] as any;
                for (let item of _data["questionBanks"])
                    this.questionBanks!.push(QuestionBankResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): InstitutionResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstitutionResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        if (Array.isArray(this.questionBanks)) {
            data["questionBanks"] = [];
            for (let item of this.questionBanks)
                data["questionBanks"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IInstitutionResponseDto extends IInstitutionRequestDto {
    questions: QuestionResponseDto[];
    questionBanks: QuestionBankResponseDto[];
}

export class QuestionBankRequestDto implements IQuestionBankRequestDto {
    id!: string;
    name!: string;
    institutionId?: string | undefined;

    constructor(data?: IQuestionBankRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.institutionId = _data["institutionId"];
        }
    }

    static fromJS(data: any): QuestionBankRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionBankRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["institutionId"] = this.institutionId;
        return data;
    }
}

export interface IQuestionBankRequestDto {
    id: string;
    name: string;
    institutionId?: string | undefined;
}

export class QuestionBankResponseDto extends QuestionBankRequestDto implements IQuestionBankResponseDto {
    institution?: InstitutionResponseDto | undefined;
    questions!: QuestionResponseDto[];
    questionsCount!: number;

    constructor(data?: IQuestionBankResponseDto) {
        super(data);
        if (!data) {
            this.questions = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.institution = _data["institution"] ? InstitutionResponseDto.fromJS(_data["institution"]) : <any>undefined;
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(QuestionResponseDto.fromJS(item));
            }
            this.questionsCount = _data["questionsCount"];
        }
    }

    static override fromJS(data: any): QuestionBankResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionBankResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["institution"] = this.institution ? this.institution.toJSON() : <any>undefined;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        data["questionsCount"] = this.questionsCount;
        super.toJSON(data);
        return data;
    }
}

export interface IQuestionBankResponseDto extends IQuestionBankRequestDto {
    institution?: InstitutionResponseDto | undefined;
    questions: QuestionResponseDto[];
    questionsCount: number;
}

/** PagedResult{TSource} */
export class PagedResultOfObservationResponseDto extends PagedResult implements IPagedResultOfObservationResponseDto {
    queryable!: ObservationResponseDto[];

    constructor(data?: IPagedResultOfObservationResponseDto) {
        super(data);
        if (!data) {
            this.queryable = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(ObservationResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PagedResultOfObservationResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfObservationResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** PagedResult{TSource} */
export interface IPagedResultOfObservationResponseDto extends IPagedResult {
    queryable: ObservationResponseDto[];
}

/** PagedResult{TSource} */
export class PagedResultOfObservationRequestResponseDto extends PagedResult implements IPagedResultOfObservationRequestResponseDto {
    queryable!: ObservationRequestResponseDto[];

    constructor(data?: IPagedResultOfObservationRequestResponseDto) {
        super(data);
        if (!data) {
            this.queryable = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(ObservationRequestResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PagedResultOfObservationRequestResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfObservationRequestResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** PagedResult{TSource} */
export interface IPagedResultOfObservationRequestResponseDto extends IPagedResult {
    queryable: ObservationRequestResponseDto[];
}

/** PagedResult{TSource} */
export class PagedResultOfQuestionBankResponseDto extends PagedResult implements IPagedResultOfQuestionBankResponseDto {
    queryable!: QuestionBankResponseDto[];

    constructor(data?: IPagedResultOfQuestionBankResponseDto) {
        super(data);
        if (!data) {
            this.queryable = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(QuestionBankResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PagedResultOfQuestionBankResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfQuestionBankResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** PagedResult{TSource} */
export interface IPagedResultOfQuestionBankResponseDto extends IPagedResult {
    queryable: QuestionBankResponseDto[];
}

/** PagedResult{TSource} */
export class PagedResultOfQuestionResponseDto extends PagedResult implements IPagedResultOfQuestionResponseDto {
    queryable!: QuestionResponseDto[];

    constructor(data?: IPagedResultOfQuestionResponseDto) {
        super(data);
        if (!data) {
            this.queryable = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(QuestionResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PagedResultOfQuestionResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfQuestionResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** PagedResult{TSource} */
export interface IPagedResultOfQuestionResponseDto extends IPagedResult {
    queryable: QuestionResponseDto[];
}

/** PagedResult{TSource} */
export class PagedResultOfQuestionRequestDto extends PagedResult implements IPagedResultOfQuestionRequestDto {
    queryable!: QuestionRequestDto[];

    constructor(data?: IPagedResultOfQuestionRequestDto) {
        super(data);
        if (!data) {
            this.queryable = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(QuestionRequestDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PagedResultOfQuestionRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfQuestionRequestDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** PagedResult{TSource} */
export interface IPagedResultOfQuestionRequestDto extends IPagedResult {
    queryable: QuestionRequestDto[];
}

/** PagedResult{TSource} */
export class PagedResultOfSelectListItem extends PagedResult implements IPagedResultOfSelectListItem {
    queryable!: SelectListItem[];

    constructor(data?: IPagedResultOfSelectListItem) {
        super(data);
        if (!data) {
            this.queryable = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(SelectListItem.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PagedResultOfSelectListItem {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfSelectListItem();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** PagedResult{TSource} */
export interface IPagedResultOfSelectListItem extends IPagedResult {
    queryable: SelectListItem[];
}

export class SelectListItem implements ISelectListItem {
    disabled!: boolean;
    group?: SelectListGroup | undefined;
    selected!: boolean;
    text?: string | undefined;
    value?: string | undefined;

    constructor(data?: ISelectListItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.disabled = _data["disabled"];
            this.group = _data["group"] ? SelectListGroup.fromJS(_data["group"]) : <any>undefined;
            this.selected = _data["selected"];
            this.text = _data["text"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SelectListItem {
        data = typeof data === 'object' ? data : {};
        let result = new SelectListItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["disabled"] = this.disabled;
        data["group"] = this.group ? this.group.toJSON() : <any>undefined;
        data["selected"] = this.selected;
        data["text"] = this.text;
        data["value"] = this.value;
        return data;
    }
}

export interface ISelectListItem {
    disabled: boolean;
    group?: SelectListGroup | undefined;
    selected: boolean;
    text?: string | undefined;
    value?: string | undefined;
}

export class SelectListGroup implements ISelectListGroup {
    disabled!: boolean;
    name?: string | undefined;

    constructor(data?: ISelectListGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.disabled = _data["disabled"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SelectListGroup {
        data = typeof data === 'object' ? data : {};
        let result = new SelectListGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["disabled"] = this.disabled;
        data["name"] = this.name;
        return data;
    }
}

export interface ISelectListGroup {
    disabled: boolean;
    name?: string | undefined;
}

/** PagedResult{TSource} */
export class PagedResultOfQuizAttemptResponseDto extends PagedResult implements IPagedResultOfQuizAttemptResponseDto {
    queryable!: QuizAttemptResponseDto[];

    constructor(data?: IPagedResultOfQuizAttemptResponseDto) {
        super(data);
        if (!data) {
            this.queryable = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(QuizAttemptResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PagedResultOfQuizAttemptResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfQuizAttemptResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** PagedResult{TSource} */
export interface IPagedResultOfQuizAttemptResponseDto extends IPagedResult {
    queryable: QuizAttemptResponseDto[];
}

/** PagedResult{TSource} */
export class PagedResultOfQuizAttemptConfigurationResponseDto extends PagedResult implements IPagedResultOfQuizAttemptConfigurationResponseDto {
    queryable!: QuizAttemptConfigurationResponseDto[];

    constructor(data?: IPagedResultOfQuizAttemptConfigurationResponseDto) {
        super(data);
        if (!data) {
            this.queryable = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(QuizAttemptConfigurationResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PagedResultOfQuizAttemptConfigurationResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfQuizAttemptConfigurationResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** PagedResult{TSource} */
export interface IPagedResultOfQuizAttemptConfigurationResponseDto extends IPagedResult {
    queryable: QuizAttemptConfigurationResponseDto[];
}

export class QuizAttemptConfigurationRequestDto implements IQuizAttemptConfigurationRequestDto {
    id?: string | undefined;
    name!: string;
    image?: string | undefined;
    description?: string | undefined;
    boards?: string[] | undefined;
    years?: number[] | undefined;
    institutions?: string[] | undefined;
    disciplines?: string[] | undefined;
    random?: boolean | undefined;
    onlyNotAnswered?: boolean | undefined;
    onlyWrongs?: boolean | undefined;
    active!: boolean;
    showOnFront!: boolean;
    users?: string[] | undefined;
    usersCount!: number;
    userIds?: string | undefined;
    crews?: CrewRequestDto[] | undefined;
    crewsCount!: number;
    crewsIds?: string | undefined;
    questions?: QuestionRequestDto[] | undefined;
    questionsCount!: number;
    questionsIds?: string | undefined;
    data?: string | undefined;

    constructor(data?: IQuizAttemptConfigurationRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.image = _data["image"];
            this.description = _data["description"];
            if (Array.isArray(_data["boards"])) {
                this.boards = [] as any;
                for (let item of _data["boards"])
                    this.boards!.push(item);
            }
            if (Array.isArray(_data["years"])) {
                this.years = [] as any;
                for (let item of _data["years"])
                    this.years!.push(item);
            }
            if (Array.isArray(_data["institutions"])) {
                this.institutions = [] as any;
                for (let item of _data["institutions"])
                    this.institutions!.push(item);
            }
            if (Array.isArray(_data["disciplines"])) {
                this.disciplines = [] as any;
                for (let item of _data["disciplines"])
                    this.disciplines!.push(item);
            }
            this.random = _data["random"];
            this.onlyNotAnswered = _data["onlyNotAnswered"];
            this.onlyWrongs = _data["onlyWrongs"];
            this.active = _data["active"];
            this.showOnFront = _data["showOnFront"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(item);
            }
            this.usersCount = _data["usersCount"];
            this.userIds = _data["userIds"];
            if (Array.isArray(_data["crews"])) {
                this.crews = [] as any;
                for (let item of _data["crews"])
                    this.crews!.push(CrewRequestDto.fromJS(item));
            }
            this.crewsCount = _data["crewsCount"];
            this.crewsIds = _data["crewsIds"];
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(QuestionRequestDto.fromJS(item));
            }
            this.questionsCount = _data["questionsCount"];
            this.questionsIds = _data["questionsIds"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): QuizAttemptConfigurationRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuizAttemptConfigurationRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["image"] = this.image;
        data["description"] = this.description;
        if (Array.isArray(this.boards)) {
            data["boards"] = [];
            for (let item of this.boards)
                data["boards"].push(item);
        }
        if (Array.isArray(this.years)) {
            data["years"] = [];
            for (let item of this.years)
                data["years"].push(item);
        }
        if (Array.isArray(this.institutions)) {
            data["institutions"] = [];
            for (let item of this.institutions)
                data["institutions"].push(item);
        }
        if (Array.isArray(this.disciplines)) {
            data["disciplines"] = [];
            for (let item of this.disciplines)
                data["disciplines"].push(item);
        }
        data["random"] = this.random;
        data["onlyNotAnswered"] = this.onlyNotAnswered;
        data["onlyWrongs"] = this.onlyWrongs;
        data["active"] = this.active;
        data["showOnFront"] = this.showOnFront;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item);
        }
        data["usersCount"] = this.usersCount;
        data["userIds"] = this.userIds;
        if (Array.isArray(this.crews)) {
            data["crews"] = [];
            for (let item of this.crews)
                data["crews"].push(item.toJSON());
        }
        data["crewsCount"] = this.crewsCount;
        data["crewsIds"] = this.crewsIds;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        data["questionsCount"] = this.questionsCount;
        data["questionsIds"] = this.questionsIds;
        data["data"] = this.data;
        return data;
    }
}

export interface IQuizAttemptConfigurationRequestDto {
    id?: string | undefined;
    name: string;
    image?: string | undefined;
    description?: string | undefined;
    boards?: string[] | undefined;
    years?: number[] | undefined;
    institutions?: string[] | undefined;
    disciplines?: string[] | undefined;
    random?: boolean | undefined;
    onlyNotAnswered?: boolean | undefined;
    onlyWrongs?: boolean | undefined;
    active: boolean;
    showOnFront: boolean;
    users?: string[] | undefined;
    usersCount: number;
    userIds?: string | undefined;
    crews?: CrewRequestDto[] | undefined;
    crewsCount: number;
    crewsIds?: string | undefined;
    questions?: QuestionRequestDto[] | undefined;
    questionsCount: number;
    questionsIds?: string | undefined;
    data?: string | undefined;
}

export class QuizAttemptConfigurationResponseDto extends QuizAttemptConfigurationRequestDto implements IQuizAttemptConfigurationResponseDto {
    institution?: InstitutionResponseDto | undefined;
    disciplines!: DisciplineResponseDto[];

    constructor(data?: IQuizAttemptConfigurationResponseDto) {
        super(data);
        if (!data) {
            this.disciplines = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.institution = _data["institution"] ? InstitutionResponseDto.fromJS(_data["institution"]) : <any>undefined;
            if (Array.isArray(_data["disciplines"])) {
                this.disciplines = [] as any;
                for (let item of _data["disciplines"])
                    this.disciplines!.push(DisciplineResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): QuizAttemptConfigurationResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuizAttemptConfigurationResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["institution"] = this.institution ? this.institution.toJSON() : <any>undefined;
        if (Array.isArray(this.disciplines)) {
            data["disciplines"] = [];
            for (let item of this.disciplines)
                data["disciplines"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IQuizAttemptConfigurationResponseDto extends IQuizAttemptConfigurationRequestDto {
    institution?: InstitutionResponseDto | undefined;
    disciplines: DisciplineResponseDto[];
}

/** PagedResult{TSource} */
export class PagedResultOfUserResponseDto extends PagedResult implements IPagedResultOfUserResponseDto {
    queryable!: UserResponseDto[];

    constructor(data?: IPagedResultOfUserResponseDto) {
        super(data);
        if (!data) {
            this.queryable = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(UserResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PagedResultOfUserResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfUserResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** PagedResult{TSource} */
export interface IPagedResultOfUserResponseDto extends IPagedResult {
    queryable: UserResponseDto[];
}

export class Headers implements IHeaders {

    [key: string]: any;

    constructor(data?: IHeaders) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Headers {
        data = typeof data === 'object' ? data : {};
        let result = new Headers();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IHeaders {

    [key: string]: any;
}

export class Headers2 implements IHeaders2 {

    [key: string]: any;

    constructor(data?: IHeaders2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Headers2 {
        data = typeof data === 'object' ? data : {};
        let result = new Headers2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IHeaders2 {

    [key: string]: any;
}

export class Headers3 implements IHeaders3 {

    [key: string]: any;

    constructor(data?: IHeaders3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Headers3 {
        data = typeof data === 'object' ? data : {};
        let result = new Headers3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IHeaders3 {

    [key: string]: any;
}

export class Headers4 implements IHeaders4 {

    [key: string]: any;

    constructor(data?: IHeaders4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Headers4 {
        data = typeof data === 'object' ? data : {};
        let result = new Headers4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IHeaders4 {

    [key: string]: any;
}

export class Headers5 implements IHeaders5 {

    [key: string]: any;

    constructor(data?: IHeaders5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Headers5 {
        data = typeof data === 'object' ? data : {};
        let result = new Headers5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IHeaders5 {

    [key: string]: any;
}

export class Headers6 implements IHeaders6 {

    [key: string]: any;

    constructor(data?: IHeaders6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Headers6 {
        data = typeof data === 'object' ? data : {};
        let result = new Headers6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IHeaders6 {

    [key: string]: any;
}

export class Headers7 implements IHeaders7 {

    [key: string]: any;

    constructor(data?: IHeaders7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Headers7 {
        data = typeof data === 'object' ? data : {};
        let result = new Headers7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IHeaders7 {

    [key: string]: any;
}

export class Headers8 implements IHeaders8 {

    [key: string]: any;

    constructor(data?: IHeaders8) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Headers8 {
        data = typeof data === 'object' ? data : {};
        let result = new Headers8();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IHeaders8 {

    [key: string]: any;
}

export class Headers9 implements IHeaders9 {

    [key: string]: any;

    constructor(data?: IHeaders9) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Headers9 {
        data = typeof data === 'object' ? data : {};
        let result = new Headers9();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IHeaders9 {

    [key: string]: any;
}

export class Headers10 implements IHeaders10 {

    [key: string]: any;

    constructor(data?: IHeaders10) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Headers10 {
        data = typeof data === 'object' ? data : {};
        let result = new Headers10();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IHeaders10 {

    [key: string]: any;
}

export class Headers11 implements IHeaders11 {

    [key: string]: any;

    constructor(data?: IHeaders11) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Headers11 {
        data = typeof data === 'object' ? data : {};
        let result = new Headers11();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IHeaders11 {

    [key: string]: any;
}

export class Headers12 implements IHeaders12 {

    [key: string]: any;

    constructor(data?: IHeaders12) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Headers12 {
        data = typeof data === 'object' ? data : {};
        let result = new Headers12();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IHeaders12 {

    [key: string]: any;
}

export class Headers13 implements IHeaders13 {

    [key: string]: any;

    constructor(data?: IHeaders13) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Headers13 {
        data = typeof data === 'object' ? data : {};
        let result = new Headers13();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IHeaders13 {

    [key: string]: any;
}

export class Queryable implements IQueryable {

    [key: string]: any;

    constructor(data?: IQueryable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Queryable {
        data = typeof data === 'object' ? data : {};
        let result = new Queryable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IQueryable {

    [key: string]: any;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}