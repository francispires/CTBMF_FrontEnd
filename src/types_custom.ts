//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.3.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class AnswerClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    getMyAnswers(signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/answers/my";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMyAnswers(_response);
        });
    }

    protected processGetMyAnswers(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    generateFakeAnswers(signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/answers/generate";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGenerateFakeAnswers(_response);
        });
    }

    protected processGenerateFakeAnswers(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Get all records of type T
     * @param currentPage (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @param filter (optional) 
     * @return A PagedResult T with queryable holding the items
     */
    getAll(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfAnswerResponseDto> {
        let url_ = this.baseUrl + "/api/answers?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<PagedResultOfAnswerResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfAnswerResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfAnswerResponseDto>(null as any);
    }

    /**
     * Create a record of type T
     * @param body The RequestDto to create object
     * @return The created item T
     */
    create(body: AnswerRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/answers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Get a record of type T by id
     * @param id The id of the item
     * @return A item T
     */
    get(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/answers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Delete a record of type T by id
     * @param id The id of the item to be removed
     * @return True on success, false otherwise
     */
    delete(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/answers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Update a record of type T by id
     * @param id The id of the item to be updated
     * @param body The updated body to be saved
     * @return True on success, false otherwise
     */
    update(id: string, body: AnswerRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/answers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    createWithFile(id: string | undefined, questionId: string | null | undefined, user: string | null | undefined, alternativeId: string | null | undefined, correct: boolean | undefined, quizAttemptId: string | null | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/answers/file";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (questionId !== null && questionId !== undefined)
            content_.append("QuestionId", questionId.toString());
        if (user !== null && user !== undefined)
            content_.append("User", user.toString());
        if (alternativeId !== null && alternativeId !== undefined)
            content_.append("AlternativeId", alternativeId.toString());
        if (correct === null || correct === undefined)
            throw new Error("The parameter 'correct' cannot be null.");
        else
            content_.append("Correct", correct.toString());
        if (quizAttemptId !== null && quizAttemptId !== undefined)
            content_.append("QuizAttemptId", quizAttemptId.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateWithFile(_response);
        });
    }

    protected processCreateWithFile(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    updateWithFile(idPath: string, idFormData: string | undefined, questionId: string | null | undefined, user: string | null | undefined, alternativeId: string | null | undefined, correct: boolean | undefined, quizAttemptId: string | null | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/answers/file";
        if (idPath === undefined || idPath === null)
            throw new Error("The parameter 'idPath' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + idPath));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (idFormData === null || idFormData === undefined)
            throw new Error("The parameter 'idFormData' cannot be null.");
        else
            content_.append("Id", idFormData.toString());
        if (questionId !== null && questionId !== undefined)
            content_.append("QuestionId", questionId.toString());
        if (user !== null && user !== undefined)
            content_.append("User", user.toString());
        if (alternativeId !== null && alternativeId !== undefined)
            content_.append("AlternativeId", alternativeId.toString());
        if (correct === null || correct === undefined)
            throw new Error("The parameter 'correct' cannot be null.");
        else
            content_.append("Correct", correct.toString());
        if (quizAttemptId !== null && quizAttemptId !== undefined)
            content_.append("QuizAttemptId", quizAttemptId.toString());

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateWithFile(_response);
        });
    }

    protected processUpdateWithFile(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload(file: FileParameter | undefined, fileName: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/answers/upload?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

export class AuthClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    signIn(user: UserCreateRequest, signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/auth/signin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSignIn(_response);
        });
    }

    protected processSignIn(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }

    signUp(user: SignupUserRequest, signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/auth/signup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSignUp(_response);
        });
    }

    protected processSignUp(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }

    create(user: UserCreateRequest, signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/auth/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }

    remove(id: string | undefined, signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/auth/remove?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemove(_response);
        });
    }

    protected processRemove(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }
}

export class DisciplinesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    /**
     * Get all records of type T
     * @param currentPage (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @param filter (optional) 
     * @return A PagedResult T with queryable holding the items
     */
    getAll(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfDisciplineResponseDto> {
        let url_ = this.baseUrl + "/api/disciplines?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<PagedResultOfDisciplineResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfDisciplineResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfDisciplineResponseDto>(null as any);
    }

    /**
     * Create a record of type T
     * @param body The RequestDto to create object
     * @return The created item T
     */
    create(body: DisciplineRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/disciplines";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Get a record of type T by id
     * @param id The id of the item
     * @return A item T
     */
    get(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/disciplines/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Delete a record of type T by id
     * @param id The id of the item to be removed
     * @return True on success, false otherwise
     */
    delete(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/disciplines/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Update a record of type T by id
     * @param id The id of the item to be updated
     * @param body The updated body to be saved
     * @return True on success, false otherwise
     */
    update(id: string, body: DisciplineRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/disciplines/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    createWithFile(id: string | undefined, name: string | undefined, description: string | undefined, image: string | null | undefined, parentId: string | null | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/disciplines/file";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (description === null || description === undefined)
            throw new Error("The parameter 'description' cannot be null.");
        else
            content_.append("Description", description.toString());
        if (image !== null && image !== undefined)
            content_.append("Image", image.toString());
        if (parentId !== null && parentId !== undefined)
            content_.append("ParentId", parentId.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateWithFile(_response);
        });
    }

    protected processCreateWithFile(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    updateWithFile(idPath: string, idFormData: string | undefined, name: string | undefined, description: string | undefined, image: string | null | undefined, parentId: string | null | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/disciplines/file";
        if (idPath === undefined || idPath === null)
            throw new Error("The parameter 'idPath' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + idPath));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (idFormData === null || idFormData === undefined)
            throw new Error("The parameter 'idFormData' cannot be null.");
        else
            content_.append("Id", idFormData.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (description === null || description === undefined)
            throw new Error("The parameter 'description' cannot be null.");
        else
            content_.append("Description", description.toString());
        if (image !== null && image !== undefined)
            content_.append("Image", image.toString());
        if (parentId !== null && parentId !== undefined)
            content_.append("ParentId", parentId.toString());

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateWithFile(_response);
        });
    }

    protected processUpdateWithFile(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload(file: FileParameter | undefined, fileName: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/disciplines/upload?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

export class ErrorClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    handleErrorDevelopmentGET(signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/error";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHandleErrorDevelopmentGET(_response);
        });
    }

    protected processHandleErrorDevelopmentGET(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    handleErrorDevelopmentPOST(signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/error";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHandleErrorDevelopmentPOST(_response);
        });
    }

    protected processHandleErrorDevelopmentPOST(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

export class InstitutionsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    /**
     * Get all records of type T
     * @param currentPage (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @param filter (optional) 
     * @return A PagedResult T with queryable holding the items
     */
    getAll(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfInstitutionResponseDto> {
        let url_ = this.baseUrl + "/api/institutions?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<PagedResultOfInstitutionResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfInstitutionResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfInstitutionResponseDto>(null as any);
    }

    /**
     * Create a record of type T
     * @param body The RequestDto to create object
     * @return The created item T
     */
    create(body: InstitutionRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/institutions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Get a record of type T by id
     * @param id The id of the item
     * @return A item T
     */
    get(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/institutions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Delete a record of type T by id
     * @param id The id of the item to be removed
     * @return True on success, false otherwise
     */
    delete(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/institutions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Update a record of type T by id
     * @param id The id of the item to be updated
     * @param body The updated body to be saved
     * @return True on success, false otherwise
     */
    update(id: string, body: InstitutionRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/institutions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    createWithFile(id: string | undefined, name: string | undefined, state: string | undefined, stadual: boolean | undefined, privateInstitution: boolean | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/institutions/file";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (state === null || state === undefined)
            throw new Error("The parameter 'state' cannot be null.");
        else
            content_.append("State", state.toString());
        if (stadual === null || stadual === undefined)
            throw new Error("The parameter 'stadual' cannot be null.");
        else
            content_.append("Stadual", stadual.toString());
        if (privateInstitution === null || privateInstitution === undefined)
            throw new Error("The parameter 'privateInstitution' cannot be null.");
        else
            content_.append("PrivateInstitution", privateInstitution.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateWithFile(_response);
        });
    }

    protected processCreateWithFile(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    updateWithFile(idPath: string, idFormData: string | undefined, name: string | undefined, state: string | undefined, stadual: boolean | undefined, privateInstitution: boolean | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/institutions/file";
        if (idPath === undefined || idPath === null)
            throw new Error("The parameter 'idPath' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + idPath));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (idFormData === null || idFormData === undefined)
            throw new Error("The parameter 'idFormData' cannot be null.");
        else
            content_.append("Id", idFormData.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (state === null || state === undefined)
            throw new Error("The parameter 'state' cannot be null.");
        else
            content_.append("State", state.toString());
        if (stadual === null || stadual === undefined)
            throw new Error("The parameter 'stadual' cannot be null.");
        else
            content_.append("Stadual", stadual.toString());
        if (privateInstitution === null || privateInstitution === undefined)
            throw new Error("The parameter 'privateInstitution' cannot be null.");
        else
            content_.append("PrivateInstitution", privateInstitution.toString());

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateWithFile(_response);
        });
    }

    protected processUpdateWithFile(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload(file: FileParameter | undefined, fileName: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/institutions/upload?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

export class MessagesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    getPublicMessage(signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/messages/public";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPublicMessage(_response);
        });
    }

    protected processGetPublicMessage(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }

    getProtectedMessage(signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/messages/protected";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProtectedMessage(_response);
        });
    }

    protected processGetProtectedMessage(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }

    getAdminMessage(signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/messages/admin";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAdminMessage(_response);
        });
    }

    protected processGetAdminMessage(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }
}

export class QuestionBankClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    /**
     * Get all records of type T
     * @param currentPage (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @param filter (optional) 
     * @return A PagedResult T with queryable holding the items
     */
    getAll(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfQuestionBankResponseDto> {
        let url_ = this.baseUrl + "/api/question_banks?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<PagedResultOfQuestionBankResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfQuestionBankResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfQuestionBankResponseDto>(null as any);
    }

    /**
     * Create a record of type T
     * @param body The RequestDto to create object
     * @return The created item T
     */
    create(body: QuestionBankRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/question_banks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Get a record of type T by id
     * @param id The id of the item
     * @return A item T
     */
    get(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/question_banks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Delete a record of type T by id
     * @param id The id of the item to be removed
     * @return True on success, false otherwise
     */
    delete(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/question_banks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Update a record of type T by id
     * @param id The id of the item to be updated
     * @param body The updated body to be saved
     * @return True on success, false otherwise
     */
    update(id: string, body: QuestionBankRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/question_banks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    createWithFile(id: string | undefined, name: string | undefined, institutionId: string | null | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/question_banks/file";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (institutionId !== null && institutionId !== undefined)
            content_.append("InstitutionId", institutionId.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateWithFile(_response);
        });
    }

    protected processCreateWithFile(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    updateWithFile(idPath: string, idFormData: string | undefined, name: string | undefined, institutionId: string | null | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/question_banks/file";
        if (idPath === undefined || idPath === null)
            throw new Error("The parameter 'idPath' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + idPath));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (idFormData === null || idFormData === undefined)
            throw new Error("The parameter 'idFormData' cannot be null.");
        else
            content_.append("Id", idFormData.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (institutionId !== null && institutionId !== undefined)
            content_.append("InstitutionId", institutionId.toString());

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateWithFile(_response);
        });
    }

    protected processUpdateWithFile(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload(file: FileParameter | undefined, fileName: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/question_banks/upload?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

export class QuestionClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    getMyAnswers(signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/questions/my";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMyAnswers(_response);
        });
    }

    protected processGetMyAnswers(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    answer(body: AnswerRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/questions/answer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAnswer(_response);
        });
    }

    protected processAnswer(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    create(body: QuestionRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/questions/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    boards(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfSelectListItem> {
        let url_ = this.baseUrl + "/api/questions/boards?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBoards(_response);
        });
    }

    protected processBoards(response: Response): Promise<PagedResultOfSelectListItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfSelectListItem.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfSelectListItem>(null as any);
    }

    numbers(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfSelectListItem> {
        let url_ = this.baseUrl + "/api/questions/numbers?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNumbers(_response);
        });
    }

    protected processNumbers(response: Response): Promise<PagedResultOfSelectListItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfSelectListItem.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfSelectListItem>(null as any);
    }

    filter(institutionIds: string[] | null | undefined, boards: string[] | null | undefined, years: number[] | null | undefined, disciplines: string[] | null | undefined, onlyAnswereds: boolean | null | undefined, onlyCorrects: boolean | null | undefined, greatherThan: number | null | undefined, lessThan: number | null | undefined, quantity: number | null | undefined, questionNumber: number | null | undefined, signal?: AbortSignal): Promise<PagedResultOfQuestionRequestDto> {
        let url_ = this.baseUrl + "/api/questions/filter?";
        if (institutionIds !== undefined && institutionIds !== null)
            institutionIds && institutionIds.forEach(item => { url_ += "InstitutionIds=" + encodeURIComponent("" + item) + "&"; });
        if (boards !== undefined && boards !== null)
            boards && boards.forEach(item => { url_ += "Boards=" + encodeURIComponent("" + item) + "&"; });
        if (years !== undefined && years !== null)
            years && years.forEach(item => { url_ += "Years=" + encodeURIComponent("" + item) + "&"; });
        if (disciplines !== undefined && disciplines !== null)
            disciplines && disciplines.forEach(item => { url_ += "Disciplines=" + encodeURIComponent("" + item) + "&"; });
        if (onlyAnswereds !== undefined && onlyAnswereds !== null)
            url_ += "OnlyAnswereds=" + encodeURIComponent("" + onlyAnswereds) + "&";
        if (onlyCorrects !== undefined && onlyCorrects !== null)
            url_ += "OnlyCorrects=" + encodeURIComponent("" + onlyCorrects) + "&";
        if (greatherThan !== undefined && greatherThan !== null)
            url_ += "GreatherThan=" + encodeURIComponent("" + greatherThan) + "&";
        if (lessThan !== undefined && lessThan !== null)
            url_ += "LessThan=" + encodeURIComponent("" + lessThan) + "&";
        if (quantity !== undefined && quantity !== null)
            url_ += "Quantity=" + encodeURIComponent("" + quantity) + "&";
        if (questionNumber !== undefined && questionNumber !== null)
            url_ += "QuestionNumber=" + encodeURIComponent("" + questionNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFilter(_response);
        });
    }

    protected processFilter(response: Response): Promise<PagedResultOfQuestionRequestDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfQuestionRequestDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfQuestionRequestDto>(null as any);
    }

    years(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfSelectListItem> {
        let url_ = this.baseUrl + "/api/questions/years?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processYears(_response);
        });
    }

    protected processYears(response: Response): Promise<PagedResultOfSelectListItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfSelectListItem.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfSelectListItem>(null as any);
    }

    /**
     * Get all records of type T
     * @param currentPage (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @param filter (optional) 
     * @return A PagedResult T with queryable holding the items
     */
    getAll(currentPage: number | undefined, pageSize: number | undefined, sort: string | null | undefined, filter: string | null | undefined, signal?: AbortSignal): Promise<PagedResultOfQuestionResponseDto> {
        let url_ = this.baseUrl + "/api/questions?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "CurrentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<PagedResultOfQuestionResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfQuestionResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfQuestionResponseDto>(null as any);
    }

    /**
     * Create a record of type T
     * @param body The RequestDto to create object
     * @return The created item T
     */
    create2(body: QuestionRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/questions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate2(_response);
        });
    }

    protected processCreate2(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Get a record of type T by id
     * @param id The id of the item
     * @return A item T
     */
    get(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/questions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Delete a record of type T by id
     * @param id The id of the item to be removed
     * @return True on success, false otherwise
     */
    delete(id: string, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/questions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * Update a record of type T by id
     * @param id The id of the item to be updated
     * @param body The updated body to be saved
     * @return True on success, false otherwise
     */
    update(id: string, body: QuestionRequestDto, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/questions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    createWithFile(id: string | undefined, year: number | undefined, board: string | undefined, image: string | null | undefined, text: string | null | undefined, score: number | undefined, active: boolean | undefined, questionNumber: number | null | undefined, institutionId: string | null | undefined, questionBankId: string | null | undefined, quizAttemptId: string | null | undefined, alternatives: AlternativeRequestDto[] | undefined, file: FileParameter | null | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/questions/file";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (year === null || year === undefined)
            throw new Error("The parameter 'year' cannot be null.");
        else
            content_.append("Year", year.toString());
        if (board === null || board === undefined)
            throw new Error("The parameter 'board' cannot be null.");
        else
            content_.append("Board", board.toString());
        if (image !== null && image !== undefined)
            content_.append("Image", image.toString());
        if (text !== null && text !== undefined)
            content_.append("Text", text.toString());
        if (score === null || score === undefined)
            throw new Error("The parameter 'score' cannot be null.");
        else
            content_.append("Score", score.toString());
        if (active === null || active === undefined)
            throw new Error("The parameter 'active' cannot be null.");
        else
            content_.append("Active", active.toString());
        if (questionNumber !== null && questionNumber !== undefined)
            content_.append("QuestionNumber", questionNumber.toString());
        if (institutionId !== null && institutionId !== undefined)
            content_.append("InstitutionId", institutionId.toString());
        if (questionBankId !== null && questionBankId !== undefined)
            content_.append("QuestionBankId", questionBankId.toString());
        if (quizAttemptId !== null && quizAttemptId !== undefined)
            content_.append("QuizAttemptId", quizAttemptId.toString());
        if (alternatives === null || alternatives === undefined)
            throw new Error("The parameter 'alternatives' cannot be null.");
        else
            alternatives.forEach(item_ => content_.append("Alternatives", item_.toString()));
        if (file !== null && file !== undefined)
            content_.append("File", file.data, file.fileName ? file.fileName : "File");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateWithFile(_response);
        });
    }

    protected processCreateWithFile(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    updateWithFile(idPath: string, idFormData: string | undefined, year: number | undefined, board: string | undefined, image: string | null | undefined, text: string | null | undefined, score: number | undefined, active: boolean | undefined, questionNumber: number | null | undefined, institutionId: string | null | undefined, questionBankId: string | null | undefined, quizAttemptId: string | null | undefined, alternatives: AlternativeRequestDto[] | undefined, file: FileParameter | null | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/questions/file";
        if (idPath === undefined || idPath === null)
            throw new Error("The parameter 'idPath' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + idPath));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (idFormData === null || idFormData === undefined)
            throw new Error("The parameter 'idFormData' cannot be null.");
        else
            content_.append("Id", idFormData.toString());
        if (year === null || year === undefined)
            throw new Error("The parameter 'year' cannot be null.");
        else
            content_.append("Year", year.toString());
        if (board === null || board === undefined)
            throw new Error("The parameter 'board' cannot be null.");
        else
            content_.append("Board", board.toString());
        if (image !== null && image !== undefined)
            content_.append("Image", image.toString());
        if (text !== null && text !== undefined)
            content_.append("Text", text.toString());
        if (score === null || score === undefined)
            throw new Error("The parameter 'score' cannot be null.");
        else
            content_.append("Score", score.toString());
        if (active === null || active === undefined)
            throw new Error("The parameter 'active' cannot be null.");
        else
            content_.append("Active", active.toString());
        if (questionNumber !== null && questionNumber !== undefined)
            content_.append("QuestionNumber", questionNumber.toString());
        if (institutionId !== null && institutionId !== undefined)
            content_.append("InstitutionId", institutionId.toString());
        if (questionBankId !== null && questionBankId !== undefined)
            content_.append("QuestionBankId", questionBankId.toString());
        if (quizAttemptId !== null && quizAttemptId !== undefined)
            content_.append("QuizAttemptId", quizAttemptId.toString());
        if (alternatives === null || alternatives === undefined)
            throw new Error("The parameter 'alternatives' cannot be null.");
        else
            alternatives.forEach(item_ => content_.append("Alternatives", item_.toString()));
        if (file !== null && file !== undefined)
            content_.append("File", file.data, file.fileName ? file.fileName : "File");

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateWithFile(_response);
        });
    }

    protected processUpdateWithFile(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    upload(file: FileParameter | undefined, fileName: string | undefined, folderName: string | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/questions/upload?";
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

export class UserClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost";
    }

    getPermissions(id: string, paginationInfo: PaginationInfo, signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/users/permissions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(paginationInfo);

        let options_: RequestInit = {
            body: content_,
            method: "GET",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPermissions(_response);
        });
    }

    protected processGetPermissions(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }

    addPermission(id: string, permissionsRequest: AssignPermissionsRequest, signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/users/permissions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(permissionsRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddPermission(_response);
        });
    }

    protected processAddPermission(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }

    getRoles(id: string, paginationInfo: PaginationInfo, signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/users/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(paginationInfo);

        let options_: RequestInit = {
            body: content_,
            method: "GET",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRoles(_response);
        });
    }

    protected processGetRoles(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }

    addRole(id: string, rolesRequest: AssignRolesRequest, signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/users/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(rolesRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddRole(_response);
        });
    }

    protected processAddRole(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }

    get(id: string, signal?: AbortSignal): Promise<Message> {
        let url_ = this.baseUrl + "/api/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<Message> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Message.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Message>(null as any);
    }

    get2(currentPage: number | undefined, pageSize: number | undefined, filter: string | null | undefined, sort: string | null | undefined, signal?: AbortSignal): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/users/all?";
        if (currentPage === null)
            throw new Error("The parameter 'currentPage' cannot be null.");
        else if (currentPage !== undefined)
            url_ += "currentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet2(_response);
        });
    }

    protected processGet2(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

/** PagedResult */
export class PagedResult implements IPagedResult {
    /** Gets or sets the queryable. */
    queryable!: Queryable[];
    /** Gets or sets the current page. */
    currentPage!: number;
    /** Gets or sets the page count. */
    pageCount!: number;
    /** Gets or sets the size of the page. */
    pageSize!: number;
    /** Gets or sets the row count. */
    rowCount!: number;

    constructor(data?: IPagedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.queryable = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(item);
            }
            this.currentPage = _data["currentPage"];
            this.pageCount = _data["pageCount"];
            this.pageSize = _data["pageSize"];
            this.rowCount = _data["rowCount"];
        }
    }

    static fromJS(data: any): PagedResult {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item);
        }
        data["currentPage"] = this.currentPage;
        data["pageCount"] = this.pageCount;
        data["pageSize"] = this.pageSize;
        data["rowCount"] = this.rowCount;
        return data;
    }
}

/** PagedResult */
export interface IPagedResult {
    /** Gets or sets the queryable. */
    queryable: Queryable[];
    /** Gets or sets the current page. */
    currentPage: number;
    /** Gets or sets the page count. */
    pageCount: number;
    /** Gets or sets the size of the page. */
    pageSize: number;
    /** Gets or sets the row count. */
    rowCount: number;
}

/** PagedResult{TSource} */
export class PagedResultOfAnswerResponseDto extends PagedResult implements IPagedResultOfAnswerResponseDto {
    queryable!: AnswerResponseDto[];

    constructor(data?: IPagedResultOfAnswerResponseDto) {
        super(data);
        if (!data) {
            this.queryable = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(AnswerResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PagedResultOfAnswerResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfAnswerResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** PagedResult{TSource} */
export interface IPagedResultOfAnswerResponseDto extends IPagedResult {
    queryable: AnswerResponseDto[];
}

export class AnswerRequestDto implements IAnswerRequestDto {
    id!: string;
    questionId?: string | undefined;
    user?: string | undefined;
    alternativeId?: string | undefined;
    correct!: boolean;
    quizAttemptId?: string | undefined;

    constructor(data?: IAnswerRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.questionId = _data["questionId"];
            this.user = _data["user"];
            this.alternativeId = _data["alternativeId"];
            this.correct = _data["correct"];
            this.quizAttemptId = _data["quizAttemptId"];
        }
    }

    static fromJS(data: any): AnswerRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new AnswerRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionId"] = this.questionId;
        data["user"] = this.user;
        data["alternativeId"] = this.alternativeId;
        data["correct"] = this.correct;
        data["quizAttemptId"] = this.quizAttemptId;
        return data;
    }
}

export interface IAnswerRequestDto {
    id: string;
    questionId?: string | undefined;
    user?: string | undefined;
    alternativeId?: string | undefined;
    correct: boolean;
    quizAttemptId?: string | undefined;
}

export class AnswerResponseDto extends AnswerRequestDto implements IAnswerResponseDto {
    question?: QuestionResponseDto | undefined;
    alternative?: AlternativeResponseDto | undefined;
    quizAttempt?: QuizAttemptResponseDto | undefined;

    constructor(data?: IAnswerResponseDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.question = _data["question"] ? QuestionResponseDto.fromJS(_data["question"]) : <any>undefined;
            this.alternative = _data["alternative"] ? AlternativeResponseDto.fromJS(_data["alternative"]) : <any>undefined;
            this.quizAttempt = _data["quizAttempt"] ? QuizAttemptResponseDto.fromJS(_data["quizAttempt"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): AnswerResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new AnswerResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["question"] = this.question ? this.question.toJSON() : <any>undefined;
        data["alternative"] = this.alternative ? this.alternative.toJSON() : <any>undefined;
        data["quizAttempt"] = this.quizAttempt ? this.quizAttempt.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IAnswerResponseDto extends IAnswerRequestDto {
    question?: QuestionResponseDto | undefined;
    alternative?: AlternativeResponseDto | undefined;
    quizAttempt?: QuizAttemptResponseDto | undefined;
}

export class HasFile implements IHasFile {
    file?: any | undefined;

    constructor(data?: IHasFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.file = _data["file"];
        }
    }

    static fromJS(data: any): HasFile {
        data = typeof data === 'object' ? data : {};
        let result = new HasFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["file"] = this.file;
        return data;
    }
}

export interface IHasFile {
    file?: any | undefined;
}

export class QuestionRequestDto extends HasFile implements IQuestionRequestDto {
    id!: string;
    year!: number;
    board!: string;
    image?: string | undefined;
    text?: string | undefined;
    score!: number;
    active!: boolean;
    questionNumber?: number | undefined;
    institutionId?: string | undefined;
    questionBankId?: string | undefined;
    quizAttemptId?: string | undefined;
    alternatives!: AlternativeRequestDto[];

    constructor(data?: IQuestionRequestDto) {
        super(data);
        if (!data) {
            this.alternatives = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.year = _data["year"];
            this.board = _data["board"];
            this.image = _data["image"];
            this.text = _data["text"];
            this.score = _data["score"];
            this.active = _data["active"];
            this.questionNumber = _data["questionNumber"];
            this.institutionId = _data["institutionId"];
            this.questionBankId = _data["questionBankId"];
            this.quizAttemptId = _data["quizAttemptId"];
            if (Array.isArray(_data["alternatives"])) {
                this.alternatives = [] as any;
                for (let item of _data["alternatives"])
                    this.alternatives!.push(AlternativeRequestDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): QuestionRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionRequestDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["year"] = this.year;
        data["board"] = this.board;
        data["image"] = this.image;
        data["text"] = this.text;
        data["score"] = this.score;
        data["active"] = this.active;
        data["questionNumber"] = this.questionNumber;
        data["institutionId"] = this.institutionId;
        data["questionBankId"] = this.questionBankId;
        data["quizAttemptId"] = this.quizAttemptId;
        if (Array.isArray(this.alternatives)) {
            data["alternatives"] = [];
            for (let item of this.alternatives)
                data["alternatives"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IQuestionRequestDto extends IHasFile {
    id: string;
    year: number;
    board: string;
    image?: string | undefined;
    text?: string | undefined;
    score: number;
    active: boolean;
    questionNumber?: number | undefined;
    institutionId?: string | undefined;
    questionBankId?: string | undefined;
    quizAttemptId?: string | undefined;
    alternatives: AlternativeRequestDto[];
}

export class QuestionResponseDto extends QuestionRequestDto implements IQuestionResponseDto {
    alternatives!: AlternativeResponseDto[];
    observations!: ObservationResponseDto[];
    answers!: AnswerResponseDto[];
    observationRequests!: ObservationRequestResponseDto[];
    disciplines!: DisciplineResponseDto[];
    questionNumber!: number;
    alternativesCount!: number;
    observationsCount!: number;
    answersCount!: number;
    observationRequestsCount!: number;
    disciplinesCount!: number;
    institutionName!: string;

    constructor(data?: IQuestionResponseDto) {
        super(data);
        if (!data) {
            this.alternatives = [];
            this.observations = [];
            this.answers = [];
            this.observationRequests = [];
            this.disciplines = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["alternatives"])) {
                this.alternatives = [] as any;
                for (let item of _data["alternatives"])
                    this.alternatives!.push(AlternativeResponseDto.fromJS(item));
            }
            if (Array.isArray(_data["observations"])) {
                this.observations = [] as any;
                for (let item of _data["observations"])
                    this.observations!.push(ObservationResponseDto.fromJS(item));
            }
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(AnswerResponseDto.fromJS(item));
            }
            if (Array.isArray(_data["observationRequests"])) {
                this.observationRequests = [] as any;
                for (let item of _data["observationRequests"])
                    this.observationRequests!.push(ObservationRequestResponseDto.fromJS(item));
            }
            if (Array.isArray(_data["disciplines"])) {
                this.disciplines = [] as any;
                for (let item of _data["disciplines"])
                    this.disciplines!.push(DisciplineResponseDto.fromJS(item));
            }
            this.questionNumber = _data["questionNumber"];
            this.alternativesCount = _data["alternativesCount"];
            this.observationsCount = _data["observationsCount"];
            this.answersCount = _data["answersCount"];
            this.observationRequestsCount = _data["observationRequestsCount"];
            this.disciplinesCount = _data["disciplinesCount"];
            this.institutionName = _data["institutionName"];
        }
    }

    static override fromJS(data: any): QuestionResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.alternatives)) {
            data["alternatives"] = [];
            for (let item of this.alternatives)
                data["alternatives"].push(item.toJSON());
        }
        if (Array.isArray(this.observations)) {
            data["observations"] = [];
            for (let item of this.observations)
                data["observations"].push(item.toJSON());
        }
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        if (Array.isArray(this.observationRequests)) {
            data["observationRequests"] = [];
            for (let item of this.observationRequests)
                data["observationRequests"].push(item.toJSON());
        }
        if (Array.isArray(this.disciplines)) {
            data["disciplines"] = [];
            for (let item of this.disciplines)
                data["disciplines"].push(item.toJSON());
        }
        data["questionNumber"] = this.questionNumber;
        data["alternativesCount"] = this.alternativesCount;
        data["observationsCount"] = this.observationsCount;
        data["answersCount"] = this.answersCount;
        data["observationRequestsCount"] = this.observationRequestsCount;
        data["disciplinesCount"] = this.disciplinesCount;
        data["institutionName"] = this.institutionName;
        super.toJSON(data);
        return data;
    }
}

export interface IQuestionResponseDto extends IQuestionRequestDto {
    alternatives: AlternativeResponseDto[];
    observations: ObservationResponseDto[];
    answers: AnswerResponseDto[];
    observationRequests: ObservationRequestResponseDto[];
    disciplines: DisciplineResponseDto[];
    questionNumber: number;
    alternativesCount: number;
    observationsCount: number;
    answersCount: number;
    observationRequestsCount: number;
    disciplinesCount: number;
    institutionName: string;
}

export class AlternativeResponseDto implements IAlternativeResponseDto {
    id?: string | undefined;
    questionId?: string | undefined;
    text!: string;
    aiExplanation!: string;
    question?: QuestionResponseDto | undefined;
    questionText!: string;
    answers!: AnswerResponseDto[];
    answersCount!: number;
    correct?:boolean;

    constructor(data?: IAlternativeResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.answers = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.questionId = _data["questionId"];
            this.text = _data["text"];
            this.aiExplanation = _data["aiExplanation"];
            this.question = _data["question"] ? QuestionResponseDto.fromJS(_data["question"]) : <any>undefined;
            this.questionText = _data["questionText"];
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(AnswerResponseDto.fromJS(item));
            }
            this.answersCount = _data["answersCount"];
        }
    }

    static fromJS(data: any): AlternativeResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlternativeResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionId"] = this.questionId;
        data["text"] = this.text;
        data["aiExplanation"] = this.aiExplanation;
        data["question"] = this.question ? this.question.toJSON() : <any>undefined;
        data["questionText"] = this.questionText;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        data["answersCount"] = this.answersCount;
        return data;
    }
}

export interface IAlternativeResponseDto {
    id?: string | undefined;
    questionId?: string | undefined;
    text: string;
    aiExplanation: string;
    question?: QuestionResponseDto | undefined;
    questionText: string;
    answers: AnswerResponseDto[];
    answersCount: number;
}

export class ObservationRequestDto implements IObservationRequestDto {
    id!: string;
    questionId?: string | undefined;
    user!: string;

    constructor(data?: IObservationRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.questionId = _data["questionId"];
            this.user = _data["user"];
        }
    }

    static fromJS(data: any): ObservationRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObservationRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionId"] = this.questionId;
        data["user"] = this.user;
        return data;
    }
}

export interface IObservationRequestDto {
    id: string;
    questionId?: string | undefined;
    user: string;
}

export class ObservationResponseDto extends ObservationRequestDto implements IObservationResponseDto {
    question?: QuestionResponseDto | undefined;

    constructor(data?: IObservationResponseDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.question = _data["question"] ? QuestionResponseDto.fromJS(_data["question"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ObservationResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObservationResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["question"] = this.question ? this.question.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IObservationResponseDto extends IObservationRequestDto {
    question?: QuestionResponseDto | undefined;
}

export class ObservationRequestRequestDto implements IObservationRequestRequestDto {
    id!: string;
    questionId?: string | undefined;
    user!: string;

    constructor(data?: IObservationRequestRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.questionId = _data["questionId"];
            this.user = _data["user"];
        }
    }

    static fromJS(data: any): ObservationRequestRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObservationRequestRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionId"] = this.questionId;
        data["user"] = this.user;
        return data;
    }
}

export interface IObservationRequestRequestDto {
    id: string;
    questionId?: string | undefined;
    user: string;
}

export class ObservationRequestResponseDto extends ObservationRequestRequestDto implements IObservationRequestResponseDto {
    question?: Question | undefined;

    constructor(data?: IObservationRequestResponseDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.question = _data["question"] ? Question.fromJS(_data["question"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ObservationRequestResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObservationRequestResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["question"] = this.question ? this.question.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IObservationRequestResponseDto extends IObservationRequestRequestDto {
    question?: Question | undefined;
}

export abstract class BaseEntity implements IBaseEntity {
    id!: string;
    createdAt!: Date;
    updatedAt?: Date | undefined;
    removedAt?: Date | undefined;
    deleted!: boolean;

    constructor(data?: IBaseEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.removedAt = _data["removedAt"] ? new Date(_data["removedAt"].toString()) : <any>undefined;
            this.deleted = _data["deleted"];
        }
    }

    static fromJS(data: any): BaseEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseEntity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["removedAt"] = this.removedAt ? this.removedAt.toISOString() : <any>undefined;
        data["deleted"] = this.deleted;
        return data;
    }
}

export interface IBaseEntity {
    id: string;
    createdAt: Date;
    updatedAt?: Date | undefined;
    removedAt?: Date | undefined;
    deleted: boolean;
}

export class Question extends BaseEntity implements IQuestion {
    active!: boolean;
    year!: number;
    board?: string | undefined;
    image?: string | undefined;
    text?: string | undefined;
    score!: number;
    questionNumber!: number;
    institutionId?: string | undefined;
    institution?: Institution | undefined;
    questionBankId?: string | undefined;
    questionBank?: QuestionBank | undefined;
    quizAttempts!: QuizAttempt[];
    alternatives!: Alternative[];
    observations!: Observation[];
    answers!: Answer[];
    observationRequests!: ObservationRequest[];
    disciplines!: Discipline[];
    isValid!: boolean;

    constructor(data?: IQuestion) {
        super(data);
        if (!data) {
            this.quizAttempts = [];
            this.alternatives = [];
            this.observations = [];
            this.answers = [];
            this.observationRequests = [];
            this.disciplines = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.active = _data["active"];
            this.year = _data["year"];
            this.board = _data["board"];
            this.image = _data["image"];
            this.text = _data["text"];
            this.score = _data["score"];
            this.questionNumber = _data["questionNumber"];
            this.institutionId = _data["institutionId"];
            this.institution = _data["institution"] ? Institution.fromJS(_data["institution"]) : <any>undefined;
            this.questionBankId = _data["questionBankId"];
            this.questionBank = _data["questionBank"] ? QuestionBank.fromJS(_data["questionBank"]) : <any>undefined;
            if (Array.isArray(_data["quizAttempts"])) {
                this.quizAttempts = [] as any;
                for (let item of _data["quizAttempts"])
                    this.quizAttempts!.push(QuizAttempt.fromJS(item));
            }
            if (Array.isArray(_data["alternatives"])) {
                this.alternatives = [] as any;
                for (let item of _data["alternatives"])
                    this.alternatives!.push(Alternative.fromJS(item));
            }
            if (Array.isArray(_data["observations"])) {
                this.observations = [] as any;
                for (let item of _data["observations"])
                    this.observations!.push(Observation.fromJS(item));
            }
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(Answer.fromJS(item));
            }
            if (Array.isArray(_data["observationRequests"])) {
                this.observationRequests = [] as any;
                for (let item of _data["observationRequests"])
                    this.observationRequests!.push(ObservationRequest.fromJS(item));
            }
            if (Array.isArray(_data["disciplines"])) {
                this.disciplines = [] as any;
                for (let item of _data["disciplines"])
                    this.disciplines!.push(Discipline.fromJS(item));
            }
            this.isValid = _data["isValid"];
        }
    }

    static override fromJS(data: any): Question {
        data = typeof data === 'object' ? data : {};
        let result = new Question();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active;
        data["year"] = this.year;
        data["board"] = this.board;
        data["image"] = this.image;
        data["text"] = this.text;
        data["score"] = this.score;
        data["questionNumber"] = this.questionNumber;
        data["institutionId"] = this.institutionId;
        data["institution"] = this.institution ? this.institution.toJSON() : <any>undefined;
        data["questionBankId"] = this.questionBankId;
        data["questionBank"] = this.questionBank ? this.questionBank.toJSON() : <any>undefined;
        if (Array.isArray(this.quizAttempts)) {
            data["quizAttempts"] = [];
            for (let item of this.quizAttempts)
                data["quizAttempts"].push(item.toJSON());
        }
        if (Array.isArray(this.alternatives)) {
            data["alternatives"] = [];
            for (let item of this.alternatives)
                data["alternatives"].push(item.toJSON());
        }
        if (Array.isArray(this.observations)) {
            data["observations"] = [];
            for (let item of this.observations)
                data["observations"].push(item.toJSON());
        }
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        if (Array.isArray(this.observationRequests)) {
            data["observationRequests"] = [];
            for (let item of this.observationRequests)
                data["observationRequests"].push(item.toJSON());
        }
        if (Array.isArray(this.disciplines)) {
            data["disciplines"] = [];
            for (let item of this.disciplines)
                data["disciplines"].push(item.toJSON());
        }
        data["isValid"] = this.isValid;
        super.toJSON(data);
        return data;
    }
}

export interface IQuestion extends IBaseEntity {
    active: boolean;
    year: number;
    board?: string | undefined;
    image?: string | undefined;
    text?: string | undefined;
    score: number;
    questionNumber: number;
    institutionId?: string | undefined;
    institution?: Institution | undefined;
    questionBankId?: string | undefined;
    questionBank?: QuestionBank | undefined;
    quizAttempts: QuizAttempt[];
    alternatives: Alternative[];
    observations: Observation[];
    answers: Answer[];
    observationRequests: ObservationRequest[];
    disciplines: Discipline[];
    isValid: boolean;
}

export class Institution extends BaseEntity implements IInstitution {
    name!: string;
    state!: string;
    stadual!: boolean;
    privateInstitution!: boolean;
    questions!: Question[];
    questionBanks!: QuestionBank[];

    constructor(data?: IInstitution) {
        super(data);
        if (!data) {
            this.questions = [];
            this.questionBanks = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.state = _data["state"];
            this.stadual = _data["stadual"];
            this.privateInstitution = _data["privateInstitution"];
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(Question.fromJS(item));
            }
            if (Array.isArray(_data["questionBanks"])) {
                this.questionBanks = [] as any;
                for (let item of _data["questionBanks"])
                    this.questionBanks!.push(QuestionBank.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Institution {
        data = typeof data === 'object' ? data : {};
        let result = new Institution();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["state"] = this.state;
        data["stadual"] = this.stadual;
        data["privateInstitution"] = this.privateInstitution;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        if (Array.isArray(this.questionBanks)) {
            data["questionBanks"] = [];
            for (let item of this.questionBanks)
                data["questionBanks"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IInstitution extends IBaseEntity {
    name: string;
    state: string;
    stadual: boolean;
    privateInstitution: boolean;
    questions: Question[];
    questionBanks: QuestionBank[];
}

export class QuestionBank extends BaseEntity implements IQuestionBank {
    name!: string;
    institution?: Institution | undefined;
    institutionId?: string | undefined;
    questions!: Question[];

    constructor(data?: IQuestionBank) {
        super(data);
        if (!data) {
            this.questions = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.institution = _data["institution"] ? Institution.fromJS(_data["institution"]) : <any>undefined;
            this.institutionId = _data["institutionId"];
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(Question.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): QuestionBank {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionBank();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["institution"] = this.institution ? this.institution.toJSON() : <any>undefined;
        data["institutionId"] = this.institutionId;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IQuestionBank extends IBaseEntity {
    name: string;
    institution?: Institution | undefined;
    institutionId?: string | undefined;
    questions: Question[];
}

export class QuizAttempt extends BaseEntity implements IQuizAttempt {
    user!: string;
    questions!: Question[];
    quizAttemptConfigurationId?: string | undefined;
    quizAttemptConfiguration?: QuizAttemptConfiguration | undefined;
    answers!: Answer[];
    startedAt!: Date;
    finishedAt?: Date | undefined;
    type!: QuizAttemptType;
    score!: number;
    total!: number;
    passed!: boolean;
    startAt?: Date | undefined;
    endAt?: Date | undefined;

    constructor(data?: IQuizAttempt) {
        super(data);
        if (!data) {
            this.questions = [];
            this.answers = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.user = _data["user"];
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(Question.fromJS(item));
            }
            this.quizAttemptConfigurationId = _data["quizAttemptConfigurationId"];
            this.quizAttemptConfiguration = _data["quizAttemptConfiguration"] ? QuizAttemptConfiguration.fromJS(_data["quizAttemptConfiguration"]) : <any>undefined;
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(Answer.fromJS(item));
            }
            this.startedAt = _data["startedAt"] ? new Date(_data["startedAt"].toString()) : <any>undefined;
            this.finishedAt = _data["finishedAt"] ? new Date(_data["finishedAt"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.score = _data["score"];
            this.total = _data["total"];
            this.passed = _data["passed"];
            this.startAt = _data["startAt"] ? new Date(_data["startAt"].toString()) : <any>undefined;
            this.endAt = _data["endAt"] ? new Date(_data["endAt"].toString()) : <any>undefined;
        }
    }

    static override fromJS(data: any): QuizAttempt {
        data = typeof data === 'object' ? data : {};
        let result = new QuizAttempt();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        data["quizAttemptConfigurationId"] = this.quizAttemptConfigurationId;
        data["quizAttemptConfiguration"] = this.quizAttemptConfiguration ? this.quizAttemptConfiguration.toJSON() : <any>undefined;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        data["startedAt"] = this.startedAt ? this.startedAt.toISOString() : <any>undefined;
        data["finishedAt"] = this.finishedAt ? this.finishedAt.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["score"] = this.score;
        data["total"] = this.total;
        data["passed"] = this.passed;
        data["startAt"] = this.startAt ? this.startAt.toISOString() : <any>undefined;
        data["endAt"] = this.endAt ? this.endAt.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IQuizAttempt extends IBaseEntity {
    user: string;
    questions: Question[];
    quizAttemptConfigurationId?: string | undefined;
    quizAttemptConfiguration?: QuizAttemptConfiguration | undefined;
    answers: Answer[];
    startedAt: Date;
    finishedAt?: Date | undefined;
    type: QuizAttemptType;
    score: number;
    total: number;
    passed: boolean;
    startAt?: Date | undefined;
    endAt?: Date | undefined;
}

export class QuizAttemptConfiguration extends BaseEntity implements IQuizAttemptConfiguration {
    name!: string;
    user!: string;
    boards!: string[];
    years!: number[];
    institutions!: string[];
    disciplines!: string[];
    random!: boolean;
    onlyNotAnswered?: boolean | undefined;
    onlyWrongs?: boolean | undefined;
    active!: boolean;
    showOnFront!: boolean;
    users!: string[];
    quizAttempts!: QuizAttempt[];
    crews!: Crew[];

    constructor(data?: IQuizAttemptConfiguration) {
        super(data);
        if (!data) {
            this.boards = [];
            this.years = [];
            this.institutions = [];
            this.disciplines = [];
            this.users = [];
            this.quizAttempts = [];
            this.crews = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.user = _data["user"];
            if (Array.isArray(_data["boards"])) {
                this.boards = [] as any;
                for (let item of _data["boards"])
                    this.boards!.push(item);
            }
            if (Array.isArray(_data["years"])) {
                this.years = [] as any;
                for (let item of _data["years"])
                    this.years!.push(item);
            }
            if (Array.isArray(_data["institutions"])) {
                this.institutions = [] as any;
                for (let item of _data["institutions"])
                    this.institutions!.push(item);
            }
            if (Array.isArray(_data["disciplines"])) {
                this.disciplines = [] as any;
                for (let item of _data["disciplines"])
                    this.disciplines!.push(item);
            }
            this.random = _data["random"];
            this.onlyNotAnswered = _data["onlyNotAnswered"];
            this.onlyWrongs = _data["onlyWrongs"];
            this.active = _data["active"];
            this.showOnFront = _data["showOnFront"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(item);
            }
            if (Array.isArray(_data["quizAttempts"])) {
                this.quizAttempts = [] as any;
                for (let item of _data["quizAttempts"])
                    this.quizAttempts!.push(QuizAttempt.fromJS(item));
            }
            if (Array.isArray(_data["crews"])) {
                this.crews = [] as any;
                for (let item of _data["crews"])
                    this.crews!.push(Crew.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): QuizAttemptConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new QuizAttemptConfiguration();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["user"] = this.user;
        if (Array.isArray(this.boards)) {
            data["boards"] = [];
            for (let item of this.boards)
                data["boards"].push(item);
        }
        if (Array.isArray(this.years)) {
            data["years"] = [];
            for (let item of this.years)
                data["years"].push(item);
        }
        if (Array.isArray(this.institutions)) {
            data["institutions"] = [];
            for (let item of this.institutions)
                data["institutions"].push(item);
        }
        if (Array.isArray(this.disciplines)) {
            data["disciplines"] = [];
            for (let item of this.disciplines)
                data["disciplines"].push(item);
        }
        data["random"] = this.random;
        data["onlyNotAnswered"] = this.onlyNotAnswered;
        data["onlyWrongs"] = this.onlyWrongs;
        data["active"] = this.active;
        data["showOnFront"] = this.showOnFront;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item);
        }
        if (Array.isArray(this.quizAttempts)) {
            data["quizAttempts"] = [];
            for (let item of this.quizAttempts)
                data["quizAttempts"].push(item.toJSON());
        }
        if (Array.isArray(this.crews)) {
            data["crews"] = [];
            for (let item of this.crews)
                data["crews"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IQuizAttemptConfiguration extends IBaseEntity {
    name: string;
    user: string;
    boards: string[];
    years: number[];
    institutions: string[];
    disciplines: string[];
    random: boolean;
    onlyNotAnswered?: boolean | undefined;
    onlyWrongs?: boolean | undefined;
    active: boolean;
    showOnFront: boolean;
    users: string[];
    quizAttempts: QuizAttempt[];
    crews: Crew[];
}

export class Crew extends BaseEntity implements ICrew {
    name!: string;
    user!: string;
    users!: string[];
    description!: string;
    data!: string;
    quizAttemptConfigurations!: QuizAttemptConfiguration[];

    constructor(data?: ICrew) {
        super(data);
        if (!data) {
            this.users = [];
            this.quizAttemptConfigurations = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.user = _data["user"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(item);
            }
            this.description = _data["description"];
            this.data = _data["data"];
            if (Array.isArray(_data["quizAttemptConfigurations"])) {
                this.quizAttemptConfigurations = [] as any;
                for (let item of _data["quizAttemptConfigurations"])
                    this.quizAttemptConfigurations!.push(QuizAttemptConfiguration.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Crew {
        data = typeof data === 'object' ? data : {};
        let result = new Crew();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["user"] = this.user;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item);
        }
        data["description"] = this.description;
        data["data"] = this.data;
        if (Array.isArray(this.quizAttemptConfigurations)) {
            data["quizAttemptConfigurations"] = [];
            for (let item of this.quizAttemptConfigurations)
                data["quizAttemptConfigurations"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface ICrew extends IBaseEntity {
    name: string;
    user: string;
    users: string[];
    description: string;
    data: string;
    quizAttemptConfigurations: QuizAttemptConfiguration[];
}

export class Answer extends BaseEntity implements IAnswer {
    question?: Question | undefined;
    questionId?: string | undefined;
    user!: string;
    alternative?: Alternative | undefined;
    alternativeId?: string | undefined;
    correct!: boolean;
    quizAttempt?: QuizAttempt | undefined;
    quizAttemptId?: string | undefined;

    constructor(data?: IAnswer) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.question = _data["question"] ? Question.fromJS(_data["question"]) : <any>undefined;
            this.questionId = _data["questionId"];
            this.user = _data["user"];
            this.alternative = _data["alternative"] ? Alternative.fromJS(_data["alternative"]) : <any>undefined;
            this.alternativeId = _data["alternativeId"];
            this.correct = _data["correct"];
            this.quizAttempt = _data["quizAttempt"] ? QuizAttempt.fromJS(_data["quizAttempt"]) : <any>undefined;
            this.quizAttemptId = _data["quizAttemptId"];
        }
    }

    static override fromJS(data: any): Answer {
        data = typeof data === 'object' ? data : {};
        let result = new Answer();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["question"] = this.question ? this.question.toJSON() : <any>undefined;
        data["questionId"] = this.questionId;
        data["user"] = this.user;
        data["alternative"] = this.alternative ? this.alternative.toJSON() : <any>undefined;
        data["alternativeId"] = this.alternativeId;
        data["correct"] = this.correct;
        data["quizAttempt"] = this.quizAttempt ? this.quizAttempt.toJSON() : <any>undefined;
        data["quizAttemptId"] = this.quizAttemptId;
        super.toJSON(data);
        return data;
    }
}

export interface IAnswer extends IBaseEntity {
    question?: Question | undefined;
    questionId?: string | undefined;
    user: string;
    alternative?: Alternative | undefined;
    alternativeId?: string | undefined;
    correct: boolean;
    quizAttempt?: QuizAttempt | undefined;
    quizAttemptId?: string | undefined;
}

export class Alternative extends BaseEntity implements IAlternative {
    questionId?: string | undefined;
    question?: Question | undefined;
    text!: string;
    correct!: boolean;
    aiExplanation?: string | undefined;
    answers!: Answer[];

    constructor(data?: IAlternative) {
        super(data);
        if (!data) {
            this.answers = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.questionId = _data["questionId"];
            this.question = _data["question"] ? Question.fromJS(_data["question"]) : <any>undefined;
            this.text = _data["text"];
            this.correct = _data["correct"];
            this.aiExplanation = _data["aiExplanation"];
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(Answer.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Alternative {
        data = typeof data === 'object' ? data : {};
        let result = new Alternative();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionId"] = this.questionId;
        data["question"] = this.question ? this.question.toJSON() : <any>undefined;
        data["text"] = this.text;
        data["correct"] = this.correct;
        data["aiExplanation"] = this.aiExplanation;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IAlternative extends IBaseEntity {
    questionId?: string | undefined;
    question?: Question | undefined;
    text: string;
    correct: boolean;
    aiExplanation?: string | undefined;
    answers: Answer[];
}

export type QuizAttemptType = 0 | 1 | 2 | 3;

export class Observation extends BaseEntity implements IObservation {
    question?: Question | undefined;
    questionId?: string | undefined;
    text!: string;
    user!: string;

    constructor(data?: IObservation) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.question = _data["question"] ? Question.fromJS(_data["question"]) : <any>undefined;
            this.questionId = _data["questionId"];
            this.text = _data["text"];
            this.user = _data["user"];
        }
    }

    static override fromJS(data: any): Observation {
        data = typeof data === 'object' ? data : {};
        let result = new Observation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["question"] = this.question ? this.question.toJSON() : <any>undefined;
        data["questionId"] = this.questionId;
        data["text"] = this.text;
        data["user"] = this.user;
        super.toJSON(data);
        return data;
    }
}

export interface IObservation extends IBaseEntity {
    question?: Question | undefined;
    questionId?: string | undefined;
    text: string;
    user: string;
}

export class ObservationRequest extends BaseEntity implements IObservationRequest {
    question?: Question | undefined;
    user!: string;
    questionId?: string | undefined;

    constructor(data?: IObservationRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.question = _data["question"] ? Question.fromJS(_data["question"]) : <any>undefined;
            this.user = _data["user"];
            this.questionId = _data["questionId"];
        }
    }

    static override fromJS(data: any): ObservationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ObservationRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["question"] = this.question ? this.question.toJSON() : <any>undefined;
        data["user"] = this.user;
        data["questionId"] = this.questionId;
        super.toJSON(data);
        return data;
    }
}

export interface IObservationRequest extends IBaseEntity {
    question?: Question | undefined;
    user: string;
    questionId?: string | undefined;
}

export class Discipline extends BaseEntity implements IDiscipline {
    name!: string;
    description!: string;
    image?: string | undefined;
    parentId?: string | undefined;
    parent?: Discipline | undefined;
    childs!: Discipline[];
    questions!: Question[];

    constructor(data?: IDiscipline) {
        super(data);
        if (!data) {
            this.childs = [];
            this.questions = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.image = _data["image"];
            this.parentId = _data["parentId"];
            this.parent = _data["parent"] ? Discipline.fromJS(_data["parent"]) : <any>undefined;
            if (Array.isArray(_data["childs"])) {
                this.childs = [] as any;
                for (let item of _data["childs"])
                    this.childs!.push(Discipline.fromJS(item));
            }
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(Question.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Discipline {
        data = typeof data === 'object' ? data : {};
        let result = new Discipline();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["image"] = this.image;
        data["parentId"] = this.parentId;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        if (Array.isArray(this.childs)) {
            data["childs"] = [];
            for (let item of this.childs)
                data["childs"].push(item.toJSON());
        }
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IDiscipline extends IBaseEntity {
    name: string;
    description: string;
    image?: string | undefined;
    parentId?: string | undefined;
    parent?: Discipline | undefined;
    childs: Discipline[];
    questions: Question[];
}

export class DisciplineRequestDto implements IDisciplineRequestDto {
    id!: string;
    name!: string;
    description!: string;
    image?: string | undefined;
    parentId?: string | undefined;

    constructor(data?: IDisciplineRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.image = _data["image"];
            this.parentId = _data["parentId"];
        }
    }

    static fromJS(data: any): DisciplineRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new DisciplineRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["image"] = this.image;
        data["parentId"] = this.parentId;
        return data;
    }
}

export interface IDisciplineRequestDto {
    id: string;
    name: string;
    description: string;
    image?: string | undefined;
    parentId?: string | undefined;
}

export class DisciplineResponseDto extends DisciplineRequestDto implements IDisciplineResponseDto {
    parentName!: string;
    childsCount!: number;
    parent?: DisciplineResponseDto | undefined;
    childs!: DisciplineResponseDto[];
    questions!: QuestionResponseDto[];

    constructor(data?: IDisciplineResponseDto) {
        super(data);
        if (!data) {
            this.childs = [];
            this.questions = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.parentName = _data["parentName"];
            this.childsCount = _data["childsCount"];
            this.parent = _data["parent"] ? DisciplineResponseDto.fromJS(_data["parent"]) : <any>undefined;
            if (Array.isArray(_data["childs"])) {
                this.childs = [] as any;
                for (let item of _data["childs"])
                    this.childs!.push(DisciplineResponseDto.fromJS(item));
            }
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(QuestionResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): DisciplineResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new DisciplineResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["childsCount"] = this.childsCount;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        if (Array.isArray(this.childs)) {
            data["childs"] = [];
            for (let item of this.childs)
                data["childs"].push(item.toJSON());
        }
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IDisciplineResponseDto extends IDisciplineRequestDto {
    parentName: string;
    childsCount: number;
    parent?: DisciplineResponseDto | undefined;
    childs: DisciplineResponseDto[];
    questions: QuestionResponseDto[];
}

export class AlternativeRequestDto implements IAlternativeRequestDto {
    id?: string | undefined;
    questionId?: string | undefined;
    text!: string;
    correct!: boolean;
    aiExplanation!: string;

    constructor(data?: IAlternativeRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.questionId = _data["questionId"];
            this.text = _data["text"];
            this.correct = _data["correct"];
            this.aiExplanation = _data["aiExplanation"];
        }
    }

    static fromJS(data: any): AlternativeRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new AlternativeRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionId"] = this.questionId;
        data["text"] = this.text;
        data["correct"] = this.correct;
        data["aiExplanation"] = this.aiExplanation;
        return data;
    }
}

export interface IAlternativeRequestDto {
    id?: string | undefined;
    questionId?: string | undefined;
    text: string;
    correct: boolean;
    aiExplanation: string;
}

export class QuizAttemptRequestDto implements IQuizAttemptRequestDto {
    id!: string;
    user!: string;
    startedAt!: Date;
    finishedAt?: Date | undefined;
    dConfigureServicesuration?: string | undefined;
    score!: number;
    total!: number;
    passed!: boolean;

    constructor(data?: IQuizAttemptRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user = _data["user"];
            this.startedAt = _data["startedAt"] ? new Date(_data["startedAt"].toString()) : <any>undefined;
            this.finishedAt = _data["finishedAt"] ? new Date(_data["finishedAt"].toString()) : <any>undefined;
            this.dConfigureServicesuration = _data["dConfigureServicesuration"];
            this.score = _data["score"];
            this.total = _data["total"];
            this.passed = _data["passed"];
        }
    }

    static fromJS(data: any): QuizAttemptRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuizAttemptRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user"] = this.user;
        data["startedAt"] = this.startedAt ? this.startedAt.toISOString() : <any>undefined;
        data["finishedAt"] = this.finishedAt ? this.finishedAt.toISOString() : <any>undefined;
        data["dConfigureServicesuration"] = this.dConfigureServicesuration;
        data["score"] = this.score;
        data["total"] = this.total;
        data["passed"] = this.passed;
        return data;
    }
}

export interface IQuizAttemptRequestDto {
    id: string;
    user: string;
    startedAt: Date;
    finishedAt?: Date | undefined;
    dConfigureServicesuration?: string | undefined;
    score: number;
    total: number;
    passed: boolean;
}

export class QuizAttemptResponseDto extends QuizAttemptRequestDto implements IQuizAttemptResponseDto {
    questions!: QuestionResponseDto[];
    answers!: AnswerResponseDto[];

    constructor(data?: IQuizAttemptResponseDto) {
        super(data);
        if (!data) {
            this.questions = [];
            this.answers = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(QuestionResponseDto.fromJS(item));
            }
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(AnswerResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): QuizAttemptResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuizAttemptResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IQuizAttemptResponseDto extends IQuizAttemptRequestDto {
    questions: QuestionResponseDto[];
    answers: AnswerResponseDto[];
}

export class Message implements IMessage {
    text?: string | undefined;

    constructor(data?: IMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): Message {
        data = typeof data === 'object' ? data : {};
        let result = new Message();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        return data;
    }
}

export interface IMessage {
    text?: string | undefined;
}

/** Contains common elements used for both constructing User-related requests, and comprising User-related responses. */
export abstract class UserBase implements IUserBase {
    /** Contains user meta data. The user has read-only access to this. */
    app_metadata?: any | undefined;
    /** Gets or sets the user's email address. */
    email?: string | undefined;
    /** Gets or sets whether the user's email address is verified. */
    email_verified?: boolean | undefined;
    /** Gets or sets the user's phone number. */
    phone_number?: string | undefined;
    /** Gets or sets whether the user's phone is verified. */
    phone_verified?: boolean | undefined;
    /** Contains user meta data. The user has read/write access to this. */
    user_metadata?: any | undefined;
    /** Gets or sets the user' username. */
    username?: string | undefined;
    /** The Nickname of the user. */
    nickname?: string | undefined;
    /** The first name of the user (if available). */
    given_name?: string | undefined;
    /** The full name of the user (e.g.: John Foo). ALWAYS GENERATED. */
    name?: string | undefined;
    /** The last name of the user (if available). */
    family_name?: string | undefined;
    /** URL pointing to the user picture (if not available, will use gravatar.com with the email). ALWAYS GENERATED */
    picture?: string | undefined;
    /** Gets or sets whether the user is blocked. True if the user is blocked, otherwise false. */
    blocked?: boolean | undefined;

    constructor(data?: IUserBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.app_metadata = _data["app_metadata"];
            this.email = _data["email"];
            this.email_verified = _data["email_verified"];
            this.phone_number = _data["phone_number"];
            this.phone_verified = _data["phone_verified"];
            this.user_metadata = _data["user_metadata"];
            this.username = _data["username"];
            this.nickname = _data["nickname"];
            this.given_name = _data["given_name"];
            this.name = _data["name"];
            this.family_name = _data["family_name"];
            this.picture = _data["picture"];
            this.blocked = _data["blocked"];
        }
    }

    static fromJS(data: any): UserBase {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'UserBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["app_metadata"] = this.app_metadata;
        data["email"] = this.email;
        data["email_verified"] = this.email_verified;
        data["phone_number"] = this.phone_number;
        data["phone_verified"] = this.phone_verified;
        data["user_metadata"] = this.user_metadata;
        data["username"] = this.username;
        data["nickname"] = this.nickname;
        data["given_name"] = this.given_name;
        data["name"] = this.name;
        data["family_name"] = this.family_name;
        data["picture"] = this.picture;
        data["blocked"] = this.blocked;
        return data;
    }
}

/** Contains common elements used for both constructing User-related requests, and comprising User-related responses. */
export interface IUserBase {
    /** Contains user meta data. The user has read-only access to this. */
    app_metadata?: any | undefined;
    /** Gets or sets the user's email address. */
    email?: string | undefined;
    /** Gets or sets whether the user's email address is verified. */
    email_verified?: boolean | undefined;
    /** Gets or sets the user's phone number. */
    phone_number?: string | undefined;
    /** Gets or sets whether the user's phone is verified. */
    phone_verified?: boolean | undefined;
    /** Contains user meta data. The user has read/write access to this. */
    user_metadata?: any | undefined;
    /** Gets or sets the user' username. */
    username?: string | undefined;
    /** The Nickname of the user. */
    nickname?: string | undefined;
    /** The first name of the user (if available). */
    given_name?: string | undefined;
    /** The full name of the user (e.g.: John Foo). ALWAYS GENERATED. */
    name?: string | undefined;
    /** The last name of the user (if available). */
    family_name?: string | undefined;
    /** URL pointing to the user picture (if not available, will use gravatar.com with the email). ALWAYS GENERATED */
    picture?: string | undefined;
    /** Gets or sets whether the user is blocked. True if the user is blocked, otherwise false. */
    blocked?: boolean | undefined;
}

/** Represents the request to create a User. */
export class UserCreateRequest extends UserBase implements IUserCreateRequest {
    /** Gets or sets the connection the user belongs to. */
    connection?: string | undefined;
    /** Gets or sets the (optional) id of the user */
    user_id?: string | undefined;
    /** Gets or sets the user's password. This is mandatory only for auth0 connection strategy. */
    password?: string | undefined;
    /** Gets or sets whether the user's email change must be verified. True if it must be verified, otherwise false. */
    verify_email?: boolean | undefined;

    constructor(data?: IUserCreateRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.connection = _data["connection"];
            this.user_id = _data["user_id"];
            this.password = _data["password"];
            this.verify_email = _data["verify_email"];
        }
    }

    static override fromJS(data: any): UserCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserCreateRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connection"] = this.connection;
        data["user_id"] = this.user_id;
        data["password"] = this.password;
        data["verify_email"] = this.verify_email;
        super.toJSON(data);
        return data;
    }
}

/** Represents the request to create a User. */
export interface IUserCreateRequest extends IUserBase {
    /** Gets or sets the connection the user belongs to. */
    connection?: string | undefined;
    /** Gets or sets the (optional) id of the user */
    user_id?: string | undefined;
    /** Gets or sets the user's password. This is mandatory only for auth0 connection strategy. */
    password?: string | undefined;
    /** Gets or sets whether the user's email change must be verified. True if it must be verified, otherwise false. */
    verify_email?: boolean | undefined;
}

/** Base class for user maintenance requests. */
export class UserMaintenanceRequestBase implements IUserMaintenanceRequestBase {
    /** Client ID of the application. */
    client_id?: string | undefined;
    /** Name of the connection. */
    connection?: string | undefined;
    /** Email address of the user. */
    email?: string | undefined;

    constructor(data?: IUserMaintenanceRequestBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.client_id = _data["client_id"];
            this.connection = _data["connection"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): UserMaintenanceRequestBase {
        data = typeof data === 'object' ? data : {};
        let result = new UserMaintenanceRequestBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["client_id"] = this.client_id;
        data["connection"] = this.connection;
        data["email"] = this.email;
        return data;
    }
}

/** Base class for user maintenance requests. */
export interface IUserMaintenanceRequestBase {
    /** Client ID of the application. */
    client_id?: string | undefined;
    /** Name of the connection. */
    connection?: string | undefined;
    /** Email address of the user. */
    email?: string | undefined;
}

/** Represents a request to sign up a new user. */
export class SignupUserRequest extends UserMaintenanceRequestBase implements ISignupUserRequest {
    /** Initial password for this user. */
    password?: string | undefined;
    /** Username of this user. Only valid if the connection requires a username. */
    username?: string | undefined;
    /** Given name for this user. */
    given_name?: string | undefined;
    /** Family name for this user. */
    family_name?: string | undefined;
    /** Name of this user. */
    name?: string | undefined;
    /** Nickname of this user. */
    nickname?: string | undefined;
    /** URL to a picture of this user. */
    picture?: string | undefined;
    /** Metadata the user has read/write access to.  */
    user_metadata?: any | undefined;

    constructor(data?: ISignupUserRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.password = _data["password"];
            this.username = _data["username"];
            this.given_name = _data["given_name"];
            this.family_name = _data["family_name"];
            this.name = _data["name"];
            this.nickname = _data["nickname"];
            this.picture = _data["picture"];
            this.user_metadata = _data["user_metadata"];
        }
    }

    static override fromJS(data: any): SignupUserRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SignupUserRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["username"] = this.username;
        data["given_name"] = this.given_name;
        data["family_name"] = this.family_name;
        data["name"] = this.name;
        data["nickname"] = this.nickname;
        data["picture"] = this.picture;
        data["user_metadata"] = this.user_metadata;
        super.toJSON(data);
        return data;
    }
}

/** Represents a request to sign up a new user. */
export interface ISignupUserRequest extends IUserMaintenanceRequestBase {
    /** Initial password for this user. */
    password?: string | undefined;
    /** Username of this user. Only valid if the connection requires a username. */
    username?: string | undefined;
    /** Given name for this user. */
    given_name?: string | undefined;
    /** Family name for this user. */
    family_name?: string | undefined;
    /** Name of this user. */
    name?: string | undefined;
    /** Nickname of this user. */
    nickname?: string | undefined;
    /** URL to a picture of this user. */
    picture?: string | undefined;
    /** Metadata the user has read/write access to.  */
    user_metadata?: any | undefined;
}

/** PagedResult{TSource} */
export class PagedResultOfDisciplineResponseDto extends PagedResult implements IPagedResultOfDisciplineResponseDto {
    queryable!: DisciplineResponseDto[];

    constructor(data?: IPagedResultOfDisciplineResponseDto) {
        super(data);
        if (!data) {
            this.queryable = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(DisciplineResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PagedResultOfDisciplineResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfDisciplineResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** PagedResult{TSource} */
export interface IPagedResultOfDisciplineResponseDto extends IPagedResult {
    queryable: DisciplineResponseDto[];
}

/** PagedResult{TSource} */
export class PagedResultOfInstitutionResponseDto extends PagedResult implements IPagedResultOfInstitutionResponseDto {
    queryable!: InstitutionResponseDto[];

    constructor(data?: IPagedResultOfInstitutionResponseDto) {
        super(data);
        if (!data) {
            this.queryable = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(InstitutionResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PagedResultOfInstitutionResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfInstitutionResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** PagedResult{TSource} */
export interface IPagedResultOfInstitutionResponseDto extends IPagedResult {
    queryable: InstitutionResponseDto[];
}

export class InstitutionRequestDto implements IInstitutionRequestDto {
    id!: string;
    name!: string;
    state!: string;
    stadual!: boolean;
    privateInstitution!: boolean;

    constructor(data?: IInstitutionRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.state = _data["state"];
            this.stadual = _data["stadual"];
            this.privateInstitution = _data["privateInstitution"];
        }
    }

    static fromJS(data: any): InstitutionRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstitutionRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["state"] = this.state;
        data["stadual"] = this.stadual;
        data["privateInstitution"] = this.privateInstitution;
        return data;
    }
}

export interface IInstitutionRequestDto {
    id: string;
    name: string;
    state: string;
    stadual: boolean;
    privateInstitution: boolean;
}

export class InstitutionResponseDto extends InstitutionRequestDto implements IInstitutionResponseDto {
    questions!: QuestionResponseDto[];
    questionBanks!: QuestionBankResponseDto[];

    constructor(data?: IInstitutionResponseDto) {
        super(data);
        if (!data) {
            this.questions = [];
            this.questionBanks = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(QuestionResponseDto.fromJS(item));
            }
            if (Array.isArray(_data["questionBanks"])) {
                this.questionBanks = [] as any;
                for (let item of _data["questionBanks"])
                    this.questionBanks!.push(QuestionBankResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): InstitutionResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstitutionResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        if (Array.isArray(this.questionBanks)) {
            data["questionBanks"] = [];
            for (let item of this.questionBanks)
                data["questionBanks"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IInstitutionResponseDto extends IInstitutionRequestDto {
    questions: QuestionResponseDto[];
    questionBanks: QuestionBankResponseDto[];
}

export class QuestionBankRequestDto implements IQuestionBankRequestDto {
    id!: string;
    name!: string;
    institutionId?: string | undefined;

    constructor(data?: IQuestionBankRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.institutionId = _data["institutionId"];
        }
    }

    static fromJS(data: any): QuestionBankRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionBankRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["institutionId"] = this.institutionId;
        return data;
    }
}

export interface IQuestionBankRequestDto {
    id: string;
    name: string;
    institutionId?: string | undefined;
}

export class QuestionBankResponseDto extends QuestionBankRequestDto implements IQuestionBankResponseDto {
    institution?: InstitutionResponseDto | undefined;
    questions!: QuestionResponseDto[];
    questionsCount!: number;

    constructor(data?: IQuestionBankResponseDto) {
        super(data);
        if (!data) {
            this.questions = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.institution = _data["institution"] ? InstitutionResponseDto.fromJS(_data["institution"]) : <any>undefined;
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(QuestionResponseDto.fromJS(item));
            }
            this.questionsCount = _data["questionsCount"];
        }
    }

    static override fromJS(data: any): QuestionBankResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionBankResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["institution"] = this.institution ? this.institution.toJSON() : <any>undefined;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        data["questionsCount"] = this.questionsCount;
        super.toJSON(data);
        return data;
    }
}

export interface IQuestionBankResponseDto extends IQuestionBankRequestDto {
    institution?: InstitutionResponseDto | undefined;
    questions: QuestionResponseDto[];
    questionsCount: number;
}

/** PagedResult{TSource} */
export class PagedResultOfQuestionBankResponseDto extends PagedResult implements IPagedResultOfQuestionBankResponseDto {
    queryable!: QuestionBankResponseDto[];

    constructor(data?: IPagedResultOfQuestionBankResponseDto) {
        super(data);
        if (!data) {
            this.queryable = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(QuestionBankResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PagedResultOfQuestionBankResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfQuestionBankResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** PagedResult{TSource} */
export interface IPagedResultOfQuestionBankResponseDto extends IPagedResult {
    queryable: QuestionBankResponseDto[];
}

/** PagedResult{TSource} */
export class PagedResultOfSelectListItem extends PagedResult implements IPagedResultOfSelectListItem {
    queryable!: SelectListItem[];

    constructor(data?: IPagedResultOfSelectListItem) {
        super(data);
        if (!data) {
            this.queryable = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(SelectListItem.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PagedResultOfSelectListItem {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfSelectListItem();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** PagedResult{TSource} */
export interface IPagedResultOfSelectListItem extends IPagedResult {
    queryable: SelectListItem[];
}

export class SelectListItem implements ISelectListItem {
    disabled!: boolean;
    group?: SelectListGroup | undefined;
    selected!: boolean;
    text?: string | undefined;
    value?: string | undefined;

    constructor(data?: ISelectListItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.disabled = _data["disabled"];
            this.group = _data["group"] ? SelectListGroup.fromJS(_data["group"]) : <any>undefined;
            this.selected = _data["selected"];
            this.text = _data["text"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SelectListItem {
        data = typeof data === 'object' ? data : {};
        let result = new SelectListItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["disabled"] = this.disabled;
        data["group"] = this.group ? this.group.toJSON() : <any>undefined;
        data["selected"] = this.selected;
        data["text"] = this.text;
        data["value"] = this.value;
        return data;
    }
}

export interface ISelectListItem {
    disabled: boolean;
    group?: SelectListGroup | undefined;
    selected: boolean;
    text?: string | undefined;
    value?: string | undefined;
}

export class SelectListGroup implements ISelectListGroup {
    disabled!: boolean;
    name?: string | undefined;

    constructor(data?: ISelectListGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.disabled = _data["disabled"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SelectListGroup {
        data = typeof data === 'object' ? data : {};
        let result = new SelectListGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["disabled"] = this.disabled;
        data["name"] = this.name;
        return data;
    }
}

export interface ISelectListGroup {
    disabled: boolean;
    name?: string | undefined;
}

/** PagedResult{TSource} */
export class PagedResultOfQuestionRequestDto extends PagedResult implements IPagedResultOfQuestionRequestDto {
    queryable!: QuestionRequestDto[];

    constructor(data?: IPagedResultOfQuestionRequestDto) {
        super(data);
        if (!data) {
            this.queryable = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(QuestionRequestDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PagedResultOfQuestionRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfQuestionRequestDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** PagedResult{TSource} */
export interface IPagedResultOfQuestionRequestDto extends IPagedResult {
    queryable: QuestionRequestDto[];
}

/** PagedResult{TSource} */
export class PagedResultOfQuestionResponseDto extends PagedResult implements IPagedResultOfQuestionResponseDto {
    queryable!: QuestionResponseDto[];

    constructor(data?: IPagedResultOfQuestionResponseDto) {
        super(data);
        if (!data) {
            this.queryable = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["queryable"])) {
                this.queryable = [] as any;
                for (let item of _data["queryable"])
                    this.queryable!.push(QuestionResponseDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PagedResultOfQuestionResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfQuestionResponseDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryable)) {
            data["queryable"] = [];
            for (let item of this.queryable)
                data["queryable"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** PagedResult{TSource} */
export interface IPagedResultOfQuestionResponseDto extends IPagedResult {
    queryable: QuestionResponseDto[];
}

/** Specifies pagination info to use when requesting paged results. */
export class PaginationInfo implements IPaginationInfo {
    /** Return results with a total result count (true) or with no totals (false, default). */
    includeTotals!: boolean;
    /** Number of results per page. */
    perPage!: number;
    /** Page index of the results to return. First page is 0. */
    pageNo!: number;

    constructor(data?: IPaginationInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.includeTotals = _data["includeTotals"];
            this.perPage = _data["perPage"];
            this.pageNo = _data["pageNo"];
        }
    }

    static fromJS(data: any): PaginationInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PaginationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["includeTotals"] = this.includeTotals;
        data["perPage"] = this.perPage;
        data["pageNo"] = this.pageNo;
        return data;
    }
}

/** Specifies pagination info to use when requesting paged results. */
export interface IPaginationInfo {
    /** Return results with a total result count (true) or with no totals (false, default). */
    includeTotals: boolean;
    /** Number of results per page. */
    perPage: number;
    /** Page index of the results to return. First page is 0. */
    pageNo: number;
}

/** Contains details of permissions that should be assigned to a role. */
export class AssignPermissionsRequest implements IAssignPermissionsRequest {
    /** User IDs to assign to the role. */
    permissions?: PermissionIdentity[] | undefined;

    constructor(data?: IAssignPermissionsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionIdentity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AssignPermissionsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AssignPermissionsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }
}

/** Contains details of permissions that should be assigned to a role. */
export interface IAssignPermissionsRequest {
    /** User IDs to assign to the role. */
    permissions?: PermissionIdentity[] | undefined;
}

/** Represents the properties of a permission that give it its unique identity. */
export class PermissionIdentity implements IPermissionIdentity {
    /** The resource server that the permission is attached to. */
    resource_server_identifier?: string | undefined;
    /** The name of the permission. */
    permission_name?: string | undefined;

    constructor(data?: IPermissionIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resource_server_identifier = _data["resource_server_identifier"];
            this.permission_name = _data["permission_name"];
        }
    }

    static fromJS(data: any): PermissionIdentity {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionIdentity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resource_server_identifier"] = this.resource_server_identifier;
        data["permission_name"] = this.permission_name;
        return data;
    }
}

/** Represents the properties of a permission that give it its unique identity. */
export interface IPermissionIdentity {
    /** The resource server that the permission is attached to. */
    resource_server_identifier?: string | undefined;
    /** The name of the permission. */
    permission_name?: string | undefined;
}

/** Contains details of roles that should be assigned to a user. */
export class AssignRolesRequest implements IAssignRolesRequest {
    /** Role IDs to assign to the user. */
    roles?: string[] | undefined;

    constructor(data?: IAssignRolesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): AssignRolesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AssignRolesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

/** Contains details of roles that should be assigned to a user. */
export interface IAssignRolesRequest {
    /** Role IDs to assign to the user. */
    roles?: string[] | undefined;
}

export class Queryable implements IQueryable {

    [key: string]: any;

    constructor(data?: IQueryable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Queryable {
        data = typeof data === 'object' ? data : {};
        let result = new Queryable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IQueryable {

    [key: string]: any;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}